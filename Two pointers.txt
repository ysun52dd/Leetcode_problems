Two Pointers#include <iostream>#include <vector>#include <unordered_map>using namespace std;
// 283. Move Zeroes// split zeros and non-zeros// the same as spliting positive and negative numbers, and spliting numbers <k and >=k.// O(n)// right pointer skips all 0's// left pointer does not skip 0'svoid moveZeroes(vector<int>& nums) {    int left;    left=0;    int size=nums.size();    for(int right=0; right<size; right++)    {        // increment right pointer 1 at a time        if(nums[right]!=0)        {            // move left pointer only when right pointer is pointing to non-zero            // and swap all non-zeros back to the left            swap(nums[left],nums[right]);            left++;        }    }}// the left side of left pointer is gauranteed to be non-zero// lintcode: partition array// Return the partitioning index, i.e the first index i nums[i] >= k.// If nums = [3,2,2,1] and k=2, a valid answer is 1.int partitionArray(vector<int> &nums, int k) {    // write your code here    int size=nums.size();    if(size==0)        return 0;    int left=0;    int right=size-1;    while(left<right)    {        while(left<right && nums[left]<k)            left++;        while(left<right && nums[right]>=k)            right--;        if(left<right)        {            swap(nums[left], nums[right]);        }    }    // left==right    if(nums[left]<k)        return left+1;    else        return left;}// lintcode: 373. Partition Array by Odd and Evenvoid partitionArray(vector<int> &nums) {    // write your code here    int size=nums.size();    if(size==0 || size==1)        return;    int left=0;    int right=size-1;    while(left<right)    {        while(left<right && nums[left]%2==1)            left++;        while(left<right && nums[right]%2==0)            right--;        if(left<right)        {            swap(nums[left], nums[right]);            // faster without these two lines            //  left++;            //  right--;        }    }    }// lintcode: 144. Interleaving Positive and Negative Numbersvoid rerange2(vector<int> &A) {    int size=A.size();    if(size==0 || size==1)        return;    int left=1;    int right=size-1;    if(size%2==1 && A[0]<0 && A[right]>0)    {        while(A[left]>0)            left++;        swap(A[left],A[right]);    }        if(size%2==0 && A[0]<0 && A[right]<0)    {        while(A[left]<0)            left++;        swap(A[left],A[right]);    }    left=1;    right=size-2;    while(left<=right)    {        while(left<=right && (A[left]*A[left-1]<0 && A[left]*A[right]>0))            left++;        while(left<=right && (A[right]*A[right+1]<0 && A[left]*A[right]>0))            right--;        if(left<=right)        {            swap(A[left], A[right]);            left++;            right--;        }    }}// correct solution:void rerange(vector<int> &A) {    int size=A.size();    if(size==0 || size==1)        return;    int left=0;    int right=size-1;    int positive=0;    int negative=0;        while(left<right)    {        while(left<right && A[left]<0)            left++;        while(left<right && A[right]>0)            right--;        if(left<right)        {            swap(A[left],A[right]);            // left++;            // right--;        }    }    // check how many positive and how many negative    if(A[left]<0){        negative=left+1;        positive=size-negative;    }    else{        negative=left;        positive=size-negative;    }    // arrange left and right pointer to skip the extra positive or negative    int newSize=0;    if(positive>=negative)    {        newSize=negative*2;        left=0;        right=newSize-1;    }    else    {        newSize=positive*2;        left=size-newSize;        right=size-1;    }        // swap left and right every 2 elements    while(left<right)    {        swap(A[left],A[right]);        left+=2;        right-=2;    }    }// lintcode: sort letters by casevoid sortLetters(string &chars) {    // write your code here    int l=chars.length();    if(l==0 || l==1)        return;    int left=0;    int right;    for(right=0; right<l;right++)    {        // if(!(chars[right]>='A'&&chars[right]<='Z'))        if(chars[right]>'Z')        {            swap(chars[left],chars[right]);            left++;        }    }}// 75. Sort Colors// manipulate vector into the order of 0, 1, and 2// version 1:void sortColors(vector<int>& nums) {    int n=nums.size();    // j is the boundary of 0, k is the boundary of 2    // i is looping through all elements until it meets k;        int j = 0, k = n - 1;    for (int i = 0; i <= k; ++i){        // if nums[i] is 0, swap it to the left and increment the j pointer        // but we need to check nums[i] again        // skip if j and i are the same        if (nums[i] == 0 && i != j){            swap(nums[i], nums[j]);            i--;            j++;        }        // if nums[i] is 2, swap it to the right and decrement the k pointer        // but we need to check nums[i] again        // skip if k and i are the same        else if (nums[i] == 2 && i != k){            swap(nums[i], nums[k]);            i--;            k--;        }    }}// version 2: faster solution !!! *******************************void sortColors2(vector<int>& nums) {    int n=nums.size();    // j is the boundary of 0, k is the boundary of 2    // i is looping through all elements until it meets k;    int j = 0, k = n-1;    for (int i=0; i <= k; i++) {        // if nums[i] is 0, swap it to the left and increment the j pointer        // and increment i since nums[i] must be 0        if (nums[i] == 0){            swap(nums[i], nums[j]);            j++;        }        // if nums[i] is 2, swap it to the right and decrement the k pointer        // but we need to check nums[i] again since the element that swapped to index i is possible to be 0 or 2        else if (nums[i] == 2){            swap(nums[i], nums[k]);            i--;            k--;        }    }}// came up with the correct algorithm, but used too many if statements (similar to move zeros)// try to use for loop instead of while loop if you know that each element need to be checked in one dirction// lintcode: 143. Sort Colors II//Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, ... k.// time complexity: nlogk// ???????????????1?k???????pivot????~k/2, ~k/4, ..., 1??????????? logk?// java://public void sortColors2(int[] colors, int k) {//    if (colors == null || colors.length == 0) {//        return;//    }//    rainbowSort(colors, 0, colors.length - 1, 1, k);//}////public void rainbowSort(int[] colors,//                        int left,//                        int right,//                        int colorFrom,//                        int colorTo) {//    if (colorFrom == colorTo) {//        return;//    }////    if (left >= right) {//        return;//    }////    int colorMid = (colorFrom + colorTo) / 2;//    int l = left, r = right;//    while (l <= r) {//        while (l <= r && colors[l] <= colorMid) {//            l++;//        }//        while (l <= r && colors[r] > colorMid) {//            r--;//        }//        if (l <= r) {//            int temp = colors[l];//            colors[l] = colors[r];//            colors[r] = temp;////            l++;//            r--;//        }//    }////    rainbowSort(colors, left, r, colorFrom, colorMid);//    rainbowSort(colors, l, right, colorMid + 1, colorTo);//}//}// 2. Two Sum// use unordered_map(hash map)// use map of <number, index> to store elements in numsvector<int> twoSum(vector<int>& nums, int target) {    unordered_map<int, int> map;    vector<int> result;    int size=nums.size();    int secondNum;    for(int i=0; i<size; i++)        map[nums[i]]=i;        for(int i=0; i<size; i++)    {        secondNum=target-nums[i];        if(map.find(secondNum)!=map.end() && map[secondNum]!=i)        {            result.push_back(i);            result.push_back(map[secondNum]);            break;        }    }    return result;}// better solution: only loop 1 time// first look for the second number (target-nums[i]) in the map, then insert the new element into mapvector<int> twoSum_2(vector<int>& nums, int target) {    unordered_map<int, int> map;    vector<int> result;    int size=nums.size();    int secondNum;        for(int i=0; i<size; i++)    {                secondNum=target-nums[i];                if(map.find(secondNum)!=map.end())        {            result.push_back(map[secondNum]);            result.push_back(i);            break;        }        map[nums[i]]=i;    }    return result;}// 167. Two Sum II - Input array is sorted// two pointers going from 2 sides to the center// if sum of left and right > target, right--// if sum of left and right < target, left++// return if sum == targetvector<int> twoSum2(vector<int>& numbers, int target) {    vector<int> result;    int size=numbers.size();    if(size==0)        return result;    int left=0;    int right=size-1;        while(left<right)    {        int sum=numbers[left]+numbers[right];        if(sum==target){            result.push_back(left+1);            result.push_back(right+1);            break;        }        if(sum>target)            right--;        else            left++;            }    return result;}// Two Sum - Unique Pairs// java version:// don't need to write sort, java has sort function Array.sort()//public int twoSum6(int[] nums, int target) {//    // Write your code here//    if (nums == null || nums.length < 2)//        return 0;////    Arrays.sort(nums);//    int cnt = 0;//    int left = 0, right = nums.length - 1;//    while (left < right) {//        int v = nums[left] + nums[right];//        if (v == target) {//            cnt ++;//            left ++;//            right --;////            while (left < right && nums[left] == nums[left - 1])//                left ++;//            while (left < right && nums[right] == nums[right + 1])//                right --;//        } else if (v > target) {//            right --;//        } else {//            left ++;//        }//    }//    return cnt;//}// 3Sum// two pinters two sum:// Time: O(n^2)  Space: O(1)// need to sort the vector first// hash map two sum:// Time: O(n^2)  Space: O(n)// but does not need to sort first// two pointers method:vector<vector<int>> threeSum(vector<int>& nums){    int size=nums.size();    vector<vector<int>> result;    if(size<3)        return result;    int left,right,target,sum;    sort(nums.begin(), nums.end());    for(int i=0; i<size-2; i++)    {        // skip the nums[i] if it is not the first number of repeated numbers        if(i>0 && nums[i]==nums[i-1])            continue;        // two sum:        left=i+1;        right=size-1;        target=-nums[i];        while(left<right)        {            // if nums[left] is not the first number of a group of the same number            // eliminate repeated nums[left]            if(left>i+1 && nums[left]==nums[left-1])            {                left++;                continue;            }            sum=nums[left]+nums[right];            if(sum==target)            {                vector<int> triplet;                triplet.push_back(nums[i]);                triplet.push_back(nums[left]);                triplet.push_back(nums[right]);                result.push_back(triplet);                left++;            }            else if(sum<target)                left++;            else                right--;        }    }    return result;    }// lintcode: 42. Maximum Subarray II//Given an array of integers, find two non-overlapping subarrays which have the largest sum.//The number in each subarray should be contiguous.//Return the largest sum.//For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, 2] or [1, 3, -1, 2] and [2], they both have the largest sum 7.// O(n), prefix sumint maxTwoSubArrays(vector<int> &nums) {    int size=nums.size();    if(size==0)        return 0;    int forward[size]; // store max of subarray sum so far going from left to right    int backward[size]; // store max of subarray sum so far from right to left    int prefixSum=0; // prefix sum at current element    int min=0; // min prefix sum before current element    int maxSum=INT_MIN; // sum of subarray, difference between 2 prefix sums    int result=INT_MIN;    // from left to right    for(int i=0; i<size-1; i++)    {        prefixSum+=nums[i];        maxSum=fmax(prefixSum-min,maxSum);        forward[i]=maxSum;        min=fmin(min,prefixSum);    }    //right to left    int prefixSum2=0; // prefix sum at current element    int min2=0; // min prefix sum before current element    int maxSum2=INT_MIN;    for(int j=size-1;j>0;j--)    {        prefixSum2+=nums[j];        maxSum2=fmax(prefixSum2-min2,maxSum2);        backward[j]=maxSum2;        min2=fmin(min2,prefixSum2);    }    // find max for the sum of forward and backward    for(int i=0;i<size-1;i++)        result=fmax(result,forward[i]+backward[i+1]);    return result;}// Two Sum - less than or equal to target// given an array of intergers, find how many pairs in the array such that their sum is less than or equal to a specific target number. Please return the number of pairs.int twoSum5(vector<int>& nums, int target){    int size=nums.size();    if(size<2)        return 0;    sort(nums.begin(),nums.end());    int left=0, right=size-1;    int count=0;    while(left<right)    {        if( nums[left]+nums[right]<=target){            // right - left = combination of nums[left] with all other numbers from nums[left+1] to nums[right] (including nums[right])            count+=right-left;            left++;        }        else            right--;    }    return count;}// 16. 3Sum Closest//Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.////Example:////Given array nums = [-1, 2, 1, -4], and target = 1.////The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).// two pointer method:// using unorded_map will be faster but consume more spaceint threeSumClosest(vector<int>& nums, int target) {    int size=nums.size();    if(size<3)        return -1;    int diff=INT_MAX;    int result;    sort(nums.begin(),nums.end());    for(int i=0; i<size-2;i++)    {        // 2 sum        int left=i+1, right=size-1;        int sum=target-nums[i];        while(left<right)        {            if(nums[left]+nums[right]<sum)            {                if(abs(sum-nums[left]-nums[right])<diff){                    diff=abs(sum-nums[left]-nums[right]);                    result=target-diff;                }                left++;            }            else{                if(abs(sum-nums[left]-nums[right])<diff){                    diff=abs(sum-nums[left]-nums[right]);                    result=target+diff;                }                right--;            }        }    }    return result;}int threeSumClosest2(vector<int>& nums, int target) {    int size=nums.size();    if(size<3)        return -1;    int diff=INT_MAX;    int result;    sort(nums.begin(),nums.end());    for(int i=0; i<size-2;i++)    {        // 2 sum        int left=i+1, right=size-1;        int sum=target-nums[i];        while(left<right)        {            if(abs(sum-nums[left]-nums[right])<diff)            {                diff=abs(sum-nums[left]-nums[right]);                result=nums[left]+nums[right]+nums[i];            }            if(nums[left]+nums[right]<sum)                left++;            else                right--;                    }    }    return result;}// 18. 4Sum// a+b+c+d = target// return a unique group of the combination of a, b, c, dvector<vector<int>> fourSum(vector<int>& nums, int target) {    vector<vector<int>> result;    unordered_map<int, vector<vector<int>>> map;    int size=nums.size();    if(size<4)        return result;    // sort the vector for later use    // only count the first number in numbers with same value    sort(nums.begin(),nums.end());    // build unordered_map, key is the sum of 2 elements, c and d    // to integers in vector are the positions of c and d with a sum of key    for(int i=0; i<size-1;i++)    {        for(int j=i+1; j<size; j++){            vector<int> ab;            ab.push_back(i);            ab.push_back(j);            map[(nums[i]+nums[j])].push_back(ab);            //cout<<"build map:"<<"\n";        }    }    // loop through a    for(int i=0; i<size-1;i++)    {        if(i>0 && nums[i]==nums[i-1])            continue;        // loop through b        for(int j=i+1; j<size; j++){            int cd=target-nums[i]-nums[j];            if(j>i+1 && nums[j]==nums[j-1])                continue;            //cout<<"a,b:"<<nums[i]<<" "<<nums[j]<<"\n";            if(map.find(cd)!=map.end() )            {                vector<int> abcd2;                for(auto n: map[cd])                {                    // c, d should be after a and b to eliminate same combination                    if(n[0]>i && n[0]>j && n[1]>i && n[1]>j ){                        // push 1 solution into result, if it is not the same result as before                        vector<int> abcd;                        abcd.push_back(nums[n[0]]);                        abcd.push_back(nums[n[1]]);                        abcd.push_back(nums[i]);                        abcd.push_back(nums[j]);                        if(abcd!=abcd2)                            result.push_back(abcd);                        abcd2=abcd;                        // cout<<"c+d:"<<cd<<"\n";                        // cout<<"get a sum:"<<abcd[0]<<" "<<abcd[1]<<" "<<abcd[2]<<" "<<abcd[3]<<"\n";                    }                }                                            }                    }            }    return result;        }// faster solution:vector<vector<int>> fourSum2(vector<int>& nums, int target) {    int len = nums.size();    int left, right, sum;    sort(nums.begin(), nums.end());    vector<vector<int>> res;    vector<int> tmp;    for (int i = 0; i < len - 3; i++) {        if (i && nums[i] == nums[i - 1]) continue;        for (int j = i + 1; j < len - 2; j++) {            if (j != i + 1 && nums[j] == nums[j - 1]) continue;            sum = target - nums[i] - nums[j];            left = j + 1;            right = len - 1;            while (left < right) {                if (nums[left] + nums[right] == sum) {                    tmp.clear();                    tmp.push_back(nums[i]);                    tmp.push_back(nums[j]);                    tmp.push_back(nums[left]);                    tmp.push_back(nums[right]);                    res.push_back(tmp);                    left++;                    right--;                    while (left < right && nums[left] == nums[left - 1]) left++;                    while (left < right && nums[right] == nums[right + 1]) right--;                } else                    if (nums[left] + nums[right] > sum) right--;                    else left++;            }        }    }    return res;}// python solution://    def fourSum(self, nums, target)://    """//    :type nums: List[int]//    :type target: int//    :rtype: List[List[int]]//    """// (like hash map in java and unordered_map in c++)//    d = dict()//    for i in range(len(nums))://      for j in range(i+1,len(nums))://          sum2 = nums[i]+nums[j]//          if sum2 in d: // if sum2 already exist//              d[sum2].append((i,j))//          else: // if this is the first sum2 in d//              d[sum2] = [(i,j)]////    result = set()//    for key in d://      value = target - key//      if value in d://          list1 = d[key]//          list2 = d[value]//          for (i,j) in list1://              for (k,l) in list2://                  if i!=k and i!=l and j!=k and j!=l://                      flist = [nums[i],nums[j],nums[k],nums[l]]//                      flist.sort()//                      result.add(tuple(flist))//    return list(result)// 42. Trapping Rain Water// Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.// version 1:// Use 2 arrays to store max from 2 sides:int trap(vector<int>& height) {    int size=height.size();    if(size<3)        return 0;    int result=0; // need to initialize result    int forward[size];    int backward[size];    int maxForward=0;    int maxBackward=0;    for(int i=0; i<size; i++){        maxForward=fmax(maxForward,height[i]);        forward[i]=maxForward;        maxBackward=fmax(maxBackward,height[size-1-i]);        backward[size-1-i]=maxBackward;    }    for(int i=0; i<size; i++){        result+=(fmin(forward[i],backward[i])-height[i]);        //cout<<"diff:"<<fmin(forward[i],backward[i])-height[i]<<"\n";    }    return result;}// Two pointers: faster version!!!// time O(n), space O(1)int trap2(vector<int>& height) {    int size=height.size();    if(size<3)        return 0;    int result=0;    int left=0, right=size-1;    int maxLeft=0, maxRight=0;    while(left<=right){        // if we know that maxLeft<=maxRight, we can confirm that at index left, the height of water si limited by the max height so far from the left (maxLeft)        if(maxLeft<=maxRight)        {            maxLeft=fmax(maxLeft,height[left]);            // so we can calculate the difference            result+=(maxLeft-height[left]);            left++;        }        else // the same for the case that maxLeft > maxRight        {            maxRight=fmax(maxRight,height[right]);            result+=(maxRight-height[right]);            right--;        }    }    // left == right + 1    // just calculated the last index with the max height    return result;}// 86. Partition List// linked list:struct ListNode {       int val;       ListNode *next;       ListNode(int x) : val(x), next(NULL) {}    };ListNode* partition(ListNode* head, int x) {    if(head==NULL)        return NULL;    ListNode* left=head;    ListNode* right=head;    ListNode* preLeft=NULL;    ListNode* preRight=NULL;        for(right=head; right!=NULL; right=right->next){        if(right->val<x)        {            // swap two nodes            ListNode* temp=left->next;            left->next=right->next;            right->next=temp;            if(preLeft!=NULL)                preLeft->next=right;            if(preRight!=NULL)                preRight->next=left;                                    // increment left            preLeft=right;            right=left;            left=preLeft->next;                    }        preRight=right;    }    return head;}// move into 2 lists, then connect the left list and right list together// O(n)ListNode* partition2(ListNode* head, int x) {    if(head==NULL)        return NULL;    ListNode* left=new ListNode(0);    ListNode* leftHead=left;    ListNode* right=new ListNode(0);    ListNode* rightHead=right;    ListNode* pre=new ListNode(0);    pre->next=head;    while(head){        // move node pointed by head to left list if val < x        if(head->val<x)        {            left->next=head;            left=left->next;        }        else { // move to right list if val >= x            right->next=head;            right=right->next;        }        pre->next=head->next;        head->next=NULL;        head=pre->next;            }    // connect left and right lists together    left->next=rightHead->next;    //rightHead->next=NULL;    //delete(rightHead);    return leftHead->next;}// 11. Container With Most Waterint maxArea(vector<int>& height) {    int size=height.size();    if(size==2)        return fmin(height[0],height[1]);    int water=INT_MIN;    int left=0,right=size-1;    while(left<=right) {        // used wrong condition: height[left-1]<=height[left]        // did not eliminate the condition that left or right pointer is at the edge        while(left<=right && left!=0 && height[left]<=height[left-1]){            left++;        }        // wrong condition: height[right-1]<=height[right]        while(left<=right && right!=size-1 && height[right]<=height[right+1]){            right--;        }        //if(left<=right){        if(height[left]<height[right]){            water=fmax(water,(right-left)*height[left]);            left++;        }                else{            water=fmax(water,(right-left)*height[right]);            right--;        }        //}    }    return water;}int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}