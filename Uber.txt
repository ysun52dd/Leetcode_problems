Uber////  Created by SunYutong on 8/28/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <string>#include <unordered_map>#include <set>#include <deque>using namespace std;// 267. Palindrome Permutation II// NOTE: don't pass visited, and p as reference, since we need to keep individual visited and p in each scope (each middle state of each permutation).// list: vector of all the chars that are going to be added to the permutation p.// p: the string contains current permutation of the first half of the palindrome.// visited: vector that indicates wether index i of the list is in string p or not.// result: result vector that contains all the valid palindrome permutations.// mid: the string that is at the middle of the palindrom.void getPerm(vector<string> &result, vector<char> list, vector<bool> visited, string p, string mid) {    int size=list.size();    // 1. Return when the permutation in p has all the char in list.    // Push the combination of string p, string mid, and p's reversed string r into the result vector.    if(p.length()==size) {        string r=p;        reverse(r.begin(), r.end());        result.push_back(p+mid+r);        return;    }        for(int i=0;i<size; ++i) {        if(!visited[i]){            // 2. Eliminate repeated permutation in p.            if(i>0 && list[i]==list[i-1] && !visited[i-1]) continue;            // 3. Restore the visited vector and update the visited vector at index i to 1.            vector<bool> v=visited;            v[i]=1;            // 4. Add one more char to the permutation string p. And call getPerm again.            getPerm(result, list, v,  p+list[i], mid);        }    }}vector<string> generatePalindromes(string s) {    int odd = 0;    string mid = "";    vector<string> result;    vector<char> list;    unordered_map<char, int> map;    int l=s.length();    // 1. Build character count map and count odds each time we meet a char in s.    for (int i = 0; i < l; ++i) {        char c = s[i];        if(map.find(c)!=map.end()) {            ++map[c];        } else            map[c]=1;        odd += map[c] & 1 != 0 ? 1 : -1;    }        // 2. If there are more than 1 char that shows up odd times in string s, we cannot form any palindromic string with all char in s.    if (odd > 1) return result;        // 3. Loop through all the key, val pairs in map, and build the elements that are to be added into the first half of the palindrome.    for (auto m : map) {        char key = m.first;        int val = m.second;                if (val & 1 != 0) mid += key;                // 4. Add each character in map val/2 times to vector list.        for (int i = 0; i < val / 2; i++) list.push_back(key);    }        vector<bool> visited(list.size(),false);    string p;    // 5. Generate all the permutations using getPerm, with empty p, and all false visited.    getPerm(result, list, visited, p, mid);        return result;    }// 359. Logger Rate Limiter (easy)//    Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.////    Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.////    It is possible that several messages arrive roughly at the same time.class Logger {public:    // Use a hash table to store the timestamp of the last log of the word.    unordered_map<string, int> map;    Logger() {            }        /** Returns true if the message should be printed in the given timestamp, otherwise returns false.     If this method returns false, the message will not be printed.     The timestamp is in seconds granularity. */    bool shouldPrintMessage(int timestamp, string message) {        if(map.count(message) && timestamp-map[message]<10) return false;        map[message]=timestamp;        return true;    }};/** * Your Logger object will be instantiated and called as such: * Logger obj = new Logger(); * bool param_1 = obj.shouldPrintMessage(timestamp,message); */// 166. Fraction to Recurring Decimal ???// Hash table, math://    Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.////    If the fractional part is repeating, enclose the repeating part in parentheses.////    Example 1://    Input: numerator = 1, denominator = 2//    Output: "0.5"//    Example 2://    Input: numerator = 2, denominator = 1//    Output: "2"//    Example 3://    Input: numerator = 2, denominator = 3//    Output: "0.(6)"// IDEA://The important thing is to consider all edge cases while thinking this problem through, including: negative integer, possible overflow, etc.////Use HashMap to store a remainder and its associated index while doing the division so that whenever a same remainder comes up, we know there is a repeating fractional part.string fractionToDecimal(int numerator, int denominator) {    if (numerator == 0) {        return "0";    }    string res="";    // "+" or "-"    res.append(((numerator > 0) ^ (denominator > 0)) ? "-" : "");    long num = abs((long)numerator);    long den = abs((long)denominator);        // integral part    res.append(to_string(num / den));    num %= den;    if (num == 0) {        return res;    }        // fractional part    res.append(".");    unordered_map<long, int> map;    map[num]=res.length();    while (num != 0) {        num *= 10;        res.append(to_string(num / den));        num %= den;        if (map.count(num)) {            int index = map[num];            res.insert(index, "(");            res.append(")");            break;        }        else {            map[num]=res.length();        }    }    return res;}// 353. Design Snake Game// Design, queue:class SnakeGame {public:    /** Initialize your data structure here.     @param width - screen width     @param height - screen height     @param food - A list of food positions     E.g food = [[1,1], [1,0]] means the first food is positioned at [1,1], the second is at [1,0]. */    // 1. width, height, and index of food that is currently on the board.    // 2. a copy of the food list.    // 3. a deque to store all the positions (pair<row, col>) of the snake, front of deque is the tail of the snake, back of deque is the head of snake.    // 4. a unordered_set that store all the positions of the snake for quickly checking wether the head of snake is overlapping with the body of the snake.    int w, h, index;    vector<pair<int, int>> f;    set<pair<int, int>> snake;    deque<pair<int, int>> q;    SnakeGame(int width, int height, vector<pair<int, int>> food) {        f = food;        w = width, h = height, index = 0;        q.push_back(make_pair(0, 0));    }        /** Moves the snake.     @param direction - 'U' = Up, 'L' = Left, 'R' = Right, 'D' = Down     @return The game's score after the move. Return -1 if game over.     Game over when snake crosses the screen boundary or bites its body. */    int move(string direction) {        // 1. Store the position of head. Delete the tail position of the snake.        int row=q.back().first, col=q.back().second;        pair<int, int> deleted=q.front(); q.pop_front();        snake.erase(deleted);        // 2. Make change to the head position based on the direction.        if(direction=="L")            --col;        else if(direction=="R")            ++col;        else if(direction=="U")            --row;        else if(direction=="D")            ++row;        // 3. Check if the head position after move is in bound, and not touching the body of snake.        if(col<0 || col>=w || row<0 || row>=h || snake.count(make_pair(row, col)))            return -1;        // 4. If legal, push the new head position to the deque, and set.        q.push_back(make_pair(row, col));        snake.insert(make_pair(row, col));        // NOTE: Must return the size-1 after pushing back the new head in deque.        // 5. If there is no more food in f vector, return the current size of deque.        if (index >= f.size())            return q.size() - 1;        // 6. check if the new head is at the position of food. If so, add the tail back in the deque and set.        if(row==f[index].first && col==f[index].second) {            q.push_front(deleted);            snake.insert(deleted);            ++index;        }        // 7. Return the size of deque - 1 as the score.        return q.size()-1;    }};/** * Your SnakeGame object will be instantiated and called as such: * SnakeGame obj = new SnakeGame(width, height, food); * int param_1 = obj.move(direction); */