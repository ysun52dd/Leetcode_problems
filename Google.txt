Google//  Created by SunYutong on 8/28/18.//  Copyright © 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <string>#include <unordered_map>#include <queue>#include <unordered_set>#include <stack>using namespace std;// 642. Design Search Autocomplete System (hard!!!)// Trie, priority queue (heap):// Each Trie node contains://      - a hash table, map, to store a mapping between all the sentences string in the history that can reach this node to the times of these sentences.//      - a vector of all pointers that point to its children nodes.//      - a bool indicating wether it is the end of a sentence.struct TrieNode {    bool isWord = false;    unordered_map<string, int> map;    vector<TrieNode*> children;    TrieNode () {        children = vector<TrieNode*>(27, NULL);            }};class Pair {public:    string s;    int c;    Pair(string str, int count) {        s = str; c = count;    }};class AutocompleteSystem {public:    // Helper function to insert a sentence into the Trie.    void insert(string &sentence, int t) {        TrieNode *iter = root;        int size=sentence.size();        for (int i = 0; i < size; ++i) {            char c=sentence[i];            int index;            if(c==' ') index=26;            else index=(int)(c-'a');                        if (iter->children[index] == NULL) {                iter->children[index] = new TrieNode();            }                        iter = iter->children[index];            if(iter->map.find(sentence)!=iter->map.end()) iter->map[sentence]+=t;            else iter->map[sentence]=t;        }        iter->isWord = true;    }        AutocompleteSystem(vector<string> sentences, vector<int> times) {        root=new TrieNode();        int size=sentences.size();        for(int i=0; i<size; ++i) {            // Insert all the sentences with their times to the Trie.            insert(sentences[i], times[i]);        }    }        // Comparator for the max heap:    // Returns true if a is less than b.    struct cmp {        bool operator()(Pair a, Pair b){            // When a and b have different count of times, the small one is the one with smaller count.            if(a.c!=b.c) return a.c<b.c;            else{ // When a and b have the same count of times.                // if a.s.compare(b.s)>0, we know that the first different char from the beginning in string a.s and b.s that has smaller ASCII number is in a.s. (a should be smaller than b)                return a.s.compare(b.s)>0 ? true:false;            }        }    };        vector<string> input(char c) {        vector<string> result;        if (c == '#') {            insert(prefix, 1);            prefix = "";            return result;        }                prefix = prefix + c;        TrieNode* curr = root;        TrieNode* next;        // Loop through all the input char on the path from the start.        for (auto c : prefix) {            if(c==' ') next=curr->children[26];            else next= curr->children[c-'a'];            if (next == NULL) {                vector<string> e;                return e;            }            curr = next;        }        // Use max heap to keep all the Pairs of the sentence string and its count of times.        priority_queue <Pair, vector<Pair>, cmp> pq;        for (auto s : curr->map) {            string sen=s.first;            int count=s.second;            Pair p=Pair(sen, count);            pq.push(p);        }                // Pop off the top 3 Pairs in max heap, and push the string in Pairs into result vector.        for (int i = 0; i < 3 && !pq.empty(); ++i) {            result.push_back(pq.top().s);            pq.pop();        }           return result;    }private:    // root is the root node of the Trie tree. Its value won't be changed after we set up the system with history vector and times vector using AutocompleteSystem().    TrieNode* root;        string prefix;};// method 2://struct TrieNode {//    bool isWord = false;//    unordered_map<string, int> map;////    vector<TrieNode*> children;//    TrieNode () {//        children = vector<TrieNode*>(27, NULL);////    }//};//class Pair {//public://    string s;//    int c;//    Pair(string str, int count) {//        s = str; c = count;//    }//};class AutocompleteSystem {public:        void insert(string &sentence, int t) {        TrieNode *iter = root;        int size=sentence.size();        for (int i = 0; i < size; ++i) {            char c=sentence[i];            int index;            if(c==' ') index=26;            else index=(int)(c-'a');                        if (iter->children[index] == NULL) {                iter->children[index] = new TrieNode();            }                        iter = iter->children[index];            if(iter->map.find(sentence)!=iter->map.end()) iter->map[sentence]+=t;            else iter->map[sentence]=t;        }        iter->isWord = true;    }        AutocompleteSystem(vector<string> sentences, vector<int> times) {        head=new TrieNode();        root=head;        int size=sentences.size();        for(int i=0; i<size; ++i) {            insert(sentences[i], times[i]);        }    }        // Comparator for the max heap. Return true if a is less than b.    struct cmp {        bool operator()(Pair a, Pair b){            if(a.c!=b.c) return a.c<b.c;            else{                return a.s.compare(b.s)>0 ? true:false;            }        }    };        vector<string> input(char c) {        vector<string> result;        if (c == '#') {            root=head;            insert(prefix, 1);            prefix = "";            return result;        }                prefix = prefix + c;        //TrieNode* curr = root;        TrieNode* next;        // Loop through all the children of curr node.               if (root == NULL ) {            vector<string> e;            return e;        }        if(c==' ') next=root->children[26];        else next= root->children[c-'a'];        if (next == NULL ) {            root=next;            vector<string> e;            return e;        }        root = next;          // Max heap.        priority_queue <Pair, vector<Pair>, cmp> pq;        for (auto s : root->map) {            string sen=s.first;            int count=s.second;            Pair p=Pair(sen, count);            pq.push(p);        }                        for (int i = 0; i < 3 && !pq.empty(); ++i) {            result.push_back(pq.top().s);            pq.pop();        }               return result;    }private:    TrieNode* root;    TrieNode* head;    string prefix;};// My best solution so far: *************************************class AutocompleteSystem {public:        void insert(string &sentence, int t) {        TrieNode *iter = root;        int size=sentence.size();        // Loop through all the char in sentence, build the Trie.        for (int i = 0; i < size; ++i) {            char c=sentence[i];            int index;            // Store char a to z at index 0 to 25, and ' ' at index 26 of children vector.            if(c==' ') index=26;            else index=(int)(c-'a');            // Add Trie node to the children vector at index based on the current char.            if (iter->children[index] == NULL) {                iter->children[index] = new TrieNode();            }                        iter = iter->children[index];            // Update the mapping of sentence in iter->map hash table with its times.            if(iter->map.find(sentence)!=iter->map.end()) iter->map[sentence]+=t;            else iter->map[sentence]=t;        }        // Set isWord to true at the end char of the input sentence.        iter->isWord = true;                    }        AutocompleteSystem(vector<string> sentences, vector<int> times) {        head=new TrieNode();        root=head;        int size=sentences.size();        for(int i=0; i<size; ++i) {            // Insert all the sentences with their times to the Trie.            insert(sentences[i], times[i]);        }    }        // Comparator for the min heap. Return true if a is greater than b.    struct cmp {    public:        bool operator()(Pair a, Pair b){            if(a.c!=b.c) return a.c>b.c;            else{                return a.s.compare(b.s)>0 ? false:true;            }        }    };    // Comparator for comparing the top Pair in the min    bool compare(Pair a, Pair b){        if(a.c!=b.c) return a.c>b.c;        else{            return a.s.compare(b.s)>0 ? false:true;        }    }        vector<string> input(char c) {        vector<string> result;        // If the input is '#', move root pointer back to the root of the Trie (head), and insert the input sentence stored in prefix into the Trie. Then clear the prefix, and return an empty result vector.        if (c == '#') {            root=head;            insert(prefix, 1);            prefix = "";            return result;        }                prefix = prefix + c;        TrieNode* next;        // Search through the Trie for the next char c, set the next pointer to the pointer that corresponding to char c in node pointed by root.        if (root == NULL ) {            //root=next;            vector<string> e;            return e;        }        if(c==' ') next=root->children[26];        else next= root->children[c-'a'];        if (next == NULL ) {            root=next;            vector<string> e;            return e;        }        root = next;             // Use min heap to keep all the Pairs of the sentence string and its count of times.        priority_queue <Pair, vector<Pair>, cmp> pq;                for (auto s : root->map) {            string sen=s.first;            int count=s.second;            Pair p=Pair(sen, count);            // Compare the to be added Pair p with the top of the min heap. If p is greater than top of the min heap, pq, then pop the top of pq and push p into pq.            if(pq.size()<3 || compare(p,pq.top())){                if(pq.size()==3)                    pq.pop();                pq.push(p);            }        }                // Pop all the pairs out of the max heap.        while(!pq.empty()) {            result.push_back(pq.top().s);            pq.pop();        }        reverse(result.begin(),result.end());        return result;    }private:    TrieNode* root;    TrieNode* head;    string prefix;};// 482. License Key Formatting//    You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.////    Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.////    Given a non-empty string S and a number K, format the string according to the rules described above.////    Example 1://    Input: S = "5F3Z-2e-9-w", K = 4//    Output: "5F3Z-2E9W"//    Explanation: The string S has been split into two parts, each part has 4 characters.//    Note that the two extra dashes are not needed and can be removed.string licenseKeyFormatting(string S, int K) {    string res;    int l=S.length();    for (int i=l-1; i >=0; --i)        if (S[i] != '-') { // ignore '-' in original string            if (res.size()%(K+1) == K) res += '-'; // every (K+1)th char is '-' from tail            res += toupper(S[i]);        }        reverse(res.begin(), res.end());    return res;}// 681. Next Closest Time// Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.// You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.// Example 1:// Input: "19:34"// Output: "19:39"// Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.string nextClosestTime(string time) {    string next=time;    unordered_set<char> set;    for(int i=0; i<5; ++i) {        if(i==2) continue;        set.insert(time[i]);    }    next[4]+=1;    bool find=false;    for(int i=4; i>=0; --i) {        if(i==2) continue;        while( next[i]=='0' || i==4 && next[i]<='9' || i==3 && next[i]<'6' || i==1 && next[i]<'4'&& next[0]=='2' || i==1 && next[i]<='9'&& next[0]=='1' || i==1 && next[i]<='9'&& next[0]=='0' || i==0 && next[i]<='2'){            if(set.find(next[i])!=set.end()) {                find=true;                break;            }            next[i]+=1;        }                if(!find){            next[i]='0';            if(i>=1 && i!=3) next[i-1]++;            if(i==3) next[i-2]++;            ++i;        }        find=false;    }    return next;}// 843. Guess the Word// Minimax://    This problem is an interactive problem new to the LeetCode platform.////    We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret.////    You may call master.guess(word) to guess a word.  The guessed word should have type string and must be from the original list with 6 lowercase letters.////    This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word.  Also, if your guess is not in the given wordlist, it will return -1 instead.////    For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase.////    Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list.  The letters of each word in those testcases were chosen independently at random from 'a' to 'z', such that every word in the given word lists is unique.////    Example 1://    Input: secret = "acckzz", wordlist = ["acckzz","ccbazz","eiowzz","abcczz"]////    Explanation://    master.guess("aaaaaa") returns -1, because "aaaaaa" is not in wordlist.//    master.guess("acckzz") returns 6, because "acckzz" is secret and has all 6 matches.//    master.guess("ccbazz") returns 3, because "ccbazz" has 3 matches.//    master.guess("eiowzz") returns 2, because "eiowzz" has 2 matches.//    master.guess("abcczz") returns 4, because "abcczz" has 4 matches.////    We made 5 calls to master.guess and one of them was the secret, so we pass the test case.// method 1:int dist(const string& a, const string &b){       int dist = 0;        for (int idx = 0; idx < 6; ++idx) {        dist += a[idx] == b[idx];    }    return dist;}void findSecretWord(vector<string>& wordlist, Master& master) {    int size=wordlist.size();    //int match;    for (int x = 0, match=0; x < 10 && match<6; ++x) {        unordered_map<string, int> count;        // build a map count which count the number of 0 matches between each word and all the other words.        for(auto w1:wordlist) for(auto w2:wordlist) if(dist(w1, w2)==0) ++count[w1];        pair<string, int> minimax=make_pair(wordlist[0], INT_MAX);        // find the word with fewest 0 matches        for(auto w:wordlist) if(count[w]<minimax.second) minimax=make_pair(w, count[w]);        match=master.guess(minimax.first);        vector<string> wordlist2;        for(auto w:wordlist) if(dist(minimax.first, w)==match) wordlist2.push_back(w);        wordlist=wordlist2;    }}// method 2: A better & faster solution:int dist(const string& a, const string &b){    // Maybe this can be memoized if too slow.    int dist = 0;        for (int idx = 0; idx < 6; ++idx) {        dist += a[idx] == b[idx];    }    return dist;}int maxEquidistantSetSize(const string& word, const unordered_set<string>& guessSet){    vector<int> hist(word.size() + 1, 0);    for (auto& guess : guessSet) {        ++hist[dist(word, guess)];    }    return *max_element(hist.cbegin(), hist.cend());}string maxPartitioningGuess(const vector<string>& wordlist, const unordered_set<string>& guessSet){    auto maxGuessIt = wordlist.cend();    int minMax = wordlist.size();    for (auto it = wordlist.cbegin(); it != wordlist.cend(); ++it) {        int curMax = maxEquidistantSetSize(*it, guessSet);        if (curMax < minMax) {            minMax = curMax;            maxGuessIt = it;        }    }    return *maxGuessIt;}void findSecretWord(vector<string>& wordlist, Master& master){    // Start guessing    unordered_set<string> guessSet(wordlist.cbegin(), wordlist.cend());    while (guessSet.size() > 1) {        // Calculate max partitioning elem taken from full word list        string guessWord = maxPartitioningGuess(wordlist, guessSet);                // Try the guess        int d = master.guess(guessWord);        if (d == guessWord.size()) return; // Got lucky! find the word!                // Eliminate words whose distance != d        for (auto it = guessSet.begin(); it != guessSet.end();) {            if (dist(guessWord, *it) != d) {                it = guessSet.erase(it);            } else {                ++it;            }        }    }    if (!guessSet.empty()) {        master.guess(*guessSet.cbegin());    }}// another version of method 2:int dist(const string& a, const string &b){    // Maybe this can be memoized if too slow.    int dist = 0;        for (int idx = 0; idx < 6; ++idx) {        dist += a[idx] == b[idx];    }    return dist;}void findSecretWord(vector<string>& wordlist, Master& master) {    int size=wordlist.size();    //int match;    for (int x = 0, match=0; x < 10 && match<6; ++x) {        unordered_map<string, int> count;        int currmax=INT_MIN;        int minimax=INT_MAX;        string maxWord;        // build a map count which count the number of 0 matches between each word and all the other words.        for(auto w1:wordlist) {            vector<int> hist(6 + 1, 0);            for(auto w2:wordlist) {                ++hist[dist(w1, w2)];            }            currmax= *max_element(hist.cbegin(), hist.cend());            if(currmax<minimax) {                minimax=currmax;                maxWord=w1;            }        }                match=master.guess(maxWord);        if(match==6) return; // NOTE: push the speed from 4ms to 0ms.                for (auto it = wordlist.begin(); it != wordlist.end();) {            if (dist(maxWord, *it) != match) {                it = wordlist.erase(it);            } else {                ++it;            }        }    }}// 399. Evaluate Division// Graph:// DFS recursion function:// return the division value between curr and target based on graph.double dfs(unordered_map<string, vector<string>>& nodeGraph, unordered_map<string, vector<double>>& edgeGraph, unordered_set<string> visited, string curr, string target) {    // 1. If the current node is the target node, return their division result, 1.    if(curr == target) return 1;    // 2. If the current node curr is visited before, it means that we have reached a leaf or a cycle, return -1 as target node not found.   if(visited.find(curr)!=visited.end()) return -1;    visited.insert(curr);    double result=-1;    string next;    int size=nodeGraph[curr].size();    // 3. Loop through all the neighbors of current node, use dfs function for neighbors, and check if we can find the target.    for(int i=0; i<size; ++i) {        next=nodeGraph[curr][i];        // 4. -If target found under the next node of curr, return the result value we found for next, multiply it by the value between curr and next.        //   -If dfs of next node returns -1 (target not found), check if there is a better result that is not -1, if all the next node of curr returns -1, keep result value as -1.        result=dfs(nodeGraph, edgeGraph,visited, next, target)!=-1? edgeGraph[curr][i]*dfs(nodeGraph, edgeGraph,visited, next, target) : fmax(result,-1);    }    return result;}vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {    unordered_map<string, vector<string>> nodeGraph;    unordered_map<string, vector<double>> edgeGraph;        int size=equations.size();    // 1. Loop through all the pairs(edges) in equations to build the graph. Push second string and the pair's value to vector that first string maps to, and push first string and the pair's value to the vector that second string maps to.    for(int i=0; i<size; ++i) {        string f=equations[i].first;        string s=equations[i].second;        // build neighbors of first node in the pair        nodeGraph[f].push_back(s);        edgeGraph[f].push_back(values[i]);        // build neighbors of second node in the pair        // *** NOTE: Need to push back 1/value of the pair !!! **********        nodeGraph[s].push_back(f);        edgeGraph[s].push_back(1/values[i]);    }    // 2. Do dfs for each pair in queries in the graph to find the multiplication of all the values from first string in the pair to the second string in the pair.    vector<double> result;    unordered_set<string> visited;    int l=queries.size();    // 3. Use dfs function for all the pairs in the querie, push back the returned values of dfs into a result vector.    // Need to check if both first string and second string are in the graph, if not, push -1 in result vector for this pair.    for(int i=0; i<l; ++i) {        string f=queries[i].first;        string s=queries[i].second;        if(nodeGraph.find(s)==nodeGraph.end() || nodeGraph.find(s)==nodeGraph.end()) {            result.push_back(-1);            continue;        }        result.push_back(dfs(nodeGraph, edgeGraph, visited, f, s));    }    return result;}// 205. Isomorphic Strings//Given two strings s and t, determine if they are isomorphic.////Two strings are isomorphic if the characters in s can be replaced to get t.////All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.////Example 1:// (1)//Input: s = "egg", t = "add"//Output: true// IMPORTANT test cases:// (2)// "ab"// "cc"// false;// (3)// "ab"// "ca"// true;// NOTE: in test case (2) and (3), we can see that the problem requires 1 to 1 mapping between all char in s and char in t.// Therefore, we need to keep 2 hash table, map1 and map2. map1 keeps mapping from t char to s char, and map2 keeps mapping from s char to t char.bool isIsomorphic(string s, string t) {    int sl=s.length();    int tl=t.length();    if(sl!=tl) return false;    // 1. Keep 2 hash table, map1 and map2. map1 keeps mapping from char in t to char in s, and map2 keeps mapping from char in s to char in t.    unordered_map<char,char> map1;    unordered_map<char,char> map2;    // 2. Loop through all char in s and t, and return true if s&t pass all following tests:    //  - If char in t has mapping but char in t is not mapped to char in s, return false.    //  - Else (if char in t does not have mapping) if both of char in t and char in s do not have mapping, map them to each other. If char in s has mapping, return false.        for(int i=0; i<tl; ++i) {        char a=t[i];        char b=s[i];        if(map1.find(a)!=map1.end()){ // have a            if(map1[a]==b)                continue;            else                return false;        }else{ // do not have a            if(map2.find(b)==map2.end()) // do not have b            {map1[a]=b; map2[b]=a;}            else // have b                return false;        }        // slower logic:            //  - If char in t has mapping but char in s does not have mapping || char in s has mapping but char in t does not have mapping, return false.            //  - If char in t and char in s both have mapping, if they are not mapped to each other, return false;            //  - Else if both of char in t and char in s do not have mapping, map them to each other.//        if(map1.find(t[i])==map1.end() && map2.find(s[i])!=map2.end() || map1.find(t[i])!=map1.end() && map2.find(s[i])==map2.end())//            return false;//        else if(map1.find(t[i])!=map1.end() && map2.find(s[i])!=map2.end()) {//            if(map1[t[i]]!=s[i] || map2[s[i]]!=t[i]) return false;//        }//        map1[t[i]]=s[i];//        map2[s[i]]=t[i];    }    return true;}// 683. K Empty Slots (hard)//    There is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then.////    Given an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day.////    For example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N.////    Also given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.////    If there isn't such day, output -1.////    Example 1://    Input://    flowers: [1,3,2]//    k: 1//    Output: 2//    Explanation: In the second day, the first and the third flower have become blooming.//    Example 2://    Input://    flowers: [1,2,3]//    k: 1//    Output: -1// BFS, O(kN) solution:int kEmptySlots(vector<int>& flowers, int k) {    int size=flowers.size();        bool isBlooming[size]={0};    bool valid=false;    for(int i=0; i<size; ++i) {        int position=flowers[i]-1;        isBlooming[position]=1;        if(position-(k+1)<0 && position+(k+1)>=size) continue;        else {            if(position-(k+1)>=0 && isBlooming[position-(k+1)]==1) {                valid=true;                for(int j=1; j<=k; ++j) {                    if(isBlooming[position-j]==true) {                        valid=false;                        break;                    }                }            }            if(valid) return i+1;            if(position+(k+1)<size && isBlooming[position+(k+1)]==1) {                valid=true;                                for(int j=1; j<=k ; ++j) {                    if(isBlooming[position+j]==true) {                        valid=false;                        break;                    }                }            }            if(valid) return i+1;        }    }    return -1;}// O(N) solution:// IDEA: Build a vector days[i] to store the date (which is the index i in flowers[i] vector, and flowers[i] is the position) that flower at position i blooms.// We just need to find a subarray days[left, left+1,..., left+k-1, right] which satisfies: for any i = left+1,..., left+k-1, we can have days[left] < days[i] && days[right] < days[i]. Then, the result is max(days[left], days[right]).int kEmptySlots2(vector<int>& flowers, int k) {    int size=flowers.size();    vector<int> days(size);    // 1. Make vector days[i] to store all the date of blooming for flower at position i.    for(int i=0; i<size; ++i) {        days[flowers[i]-1]=i+1;    }    // 2. Set the left boundary of the K interval, loop through the days[i] vector to compare days[i] with the left and right boundary's date.    //  - If days[i] is smaller than left and right boundary's date, update left boundary.    //  - If i is at the right boundary, update the result with the max date between left and right boundary's dates, keep the min of result.    int left=0;    int right=k+1;    int result=INT_MAX;    for(int i=1; right<size; ++i) {                if(days[i]<days[left] || days[i]<=days[right]) {            if(i==right) result=min(result,max(days[left],days[right]));            left=i;            right=i+k+1;        }    }    return result==INT_MAX? -1:result;}// 686. Repeated String Match// String://    Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.////    For example, with A = "abcd" and B = "cdabcdab".//    Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd").// IMPORTANT: string function to check if string B is a substring of string A: A.find(B)!=string::nposint repeatedStringMatch(string A, string B) {    string tempA=A; // NOTE: remember to keep the initial A string and append the initial A to the n times of A.    int times=1;    // 1. Append original A string to itself and count how many time A is appended. Stop when A and B have same length or A is longer than B.    while(A.length()<B.length()){        A.append(tempA);        ++times;    }    // 2. use find function to see wether B is a substring of A.    // - If A does not contain B, append 1 more A and check if A has B. Else return the count of times.    //   - If A still does not contain B, return -1.    //   - If contians, return the count of times.    if(A.find(B)==string::npos) {        A.append(tempA); ++times;        if(A.find(B)==string::npos) return -1;        else return times;    }    else return times;    }// 734. Sentence Similarity (easy)// Hash table:// NOTE: can't use unordered_set, pair inside unordered_map and unordered_set// if we want to store multiple mapping to one key, we need to use vector. unordered_map<string, vector<string>> map;bool areSentencesSimilar(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {    int s1=words1.size();    int s2=words2.size();    if(s1!=s2) return false;    unordered_map<string, vector<string>> map;    for(auto p:pairs) map[p.first].push_back(p.second);        for(int i=0; i<s1; ++i) {        if(words1[i]==words2[i]) continue;        bool skip=false;        if(map.find(words1[i])==map.end() && map.find(words2[i])==map.end()) return false;        if(map.find(words1[i])!=map.end() ) {            for(auto w:map[words1[i]]) if(w==words2[i]) skip=true;        }        if(map.find(words2[i])!=map.end()) {            for(auto w:map[words2[i]]) if(w==words1[i]) skip=true;        }        if(!skip)            return false;    }    return true;}// 737. Sentence Similarity II// DFS, union find://    Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.////    For example, words1 = ["great", "acting", "skills"] and words2 = ["fine", "drama", "talent"] are similar, if the similar word pairs are pairs = [["great", "good"], ["fine", "good"], ["acting","drama"], ["skills","talent"]].////    Note that the similarity relation is transitive. For example, if "great" and "good" are similar, and "fine" and "good" are similar, then "great" and "fine" are similar.////    Similarity is also symmetric. For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.////    Also, a word is always similar with itself. For example, the sentences words1 = ["great"], words2 = ["great"], pairs = [] are similar, even though there are no specified similar word pairs.////    Finally, sentences can only be similar if they have the same number of words. So a sentence like words1 = ["great"] can never be similar to words2 = ["doubleplus","good"].// A function that finds the parent string of the group that string s belongs to in map.string find(unordered_map<string, string> &map, string s) {    // 1. If the string is not seen before, we can map it to itself, and return itself as the parent.    if(!map.count(s)) map[s]=s;    // 2. return the parent the string that we are looking for s is the parent node in the map, return itself, if it is not, check if the string that s maps to is the parent string, and the parent string is a string that maps to itself.    return (map[s]==s)? s:find(map, map[s]);}bool areSentencesSimilarTwo(vector<string>& words1, vector<string>& words2, vector<pair<string, string>> pairs) {    int s1=words1.size();    int s2=words2.size();    if(s1!=s2) return false;    unordered_map<string, string> map;    for(auto p:pairs) {        // 1. Loop through pairs to build the map, group all strings with the same parent together. Find the parent string of the two strings in the pair.        string parent1=find(map,p.first);        string parent2=find(map,p.second);        // 2. If the 2 strings in the pair p do not have the same parent string, map the first parent string to the second parent string. (point the next node of the parent1 node to the parent2 node, so that the parent strings of all the strings that used to be under parent1 are switched to parent2.        if(parent1!=parent2) map[parent1]=parent2;    }    // 3. Loop through words1 and words2,    //   - if 2 words are the same, move to the next word.    //   - if the parent string of the word in words1 is not the same as the parent string of the word in words2, the 2 sentences do not match.    for(int i=0; i<s1; ++i) {        if(words1[i]==words2[i]) continue;        if(find(map,words1[i])!=find(map,words2[i])) return false;    }    return true;}// 844. Backspace String Compare//Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.////Example 1://Input: S = "ab#c", T = "ad#c"//Output: true//Explanation: Both S and T become "ac".//Example 2://Input: S = "ab##", T = "c#d#"//Output: true//Explanation: Both S and T become "".// Stack: O(n) time, O(n) space:bool backspaceCompare(string S, string T) {    stack<char> s;    int sizeS=S.length();    int sizeT=T.length();    for(auto c:S) {        if(c=='#') {            if(!s.empty()) s.pop();            else continue;        }        else s.push(c);    }    string tempS;    while(!s.empty()) {        tempS.append(to_string(s.top()));        s.pop();    }    for(auto c:T) {        if(c=='#') {            if(!s.empty())                s.pop();            else continue;        }        else s.push(c);    }    string tempT;    while(!s.empty()) {        tempT.append(to_string(s.top()));        s.pop();    }    return tempT==tempS;}// Follow up:// Can you do it in O(N) time and O(1) space?// Two pointers:bool backspaceCompare(string S, string T) {    int a=S.length()-1, b=T.length()-1;    int back=0;    while(a>=0 || b>=0) {        back=0;        while(a>=0  && (back>0 || S[a]=='#')) {            back+= S[a]=='#'? 1:-1;            --a;        }        back=0;        while( b>=0 && (back>0 || T[b]=='#')) {            back+= T[b]=='#'? 1:-1;            --b;        }        if(a>=0 || b>=0) {            if(S[a]!=T[b]) return false;            --a;            --b;        }    }    if(a<0 && b<0) return true;    else return false;    }// leetCode solution:bool backspaceCompare(string S, string T) {    int i = S.length() - 1, j = T.length() - 1;    while (1) {        for (int back = 0; i >= 0 && (back || S[i] == '#'); --i)            back += S[i] == '#' ? 1 : -1;        for (int back = 0; j >= 0 && (back || T[j] == '#'); --j)            back += T[j] == '#' ? 1 : -1;        if (i >= 0 && j >= 0 && S[i] == T[j])            i--, j--;        else            return i == -1 && j == -1;    }}// 159. Longest Substring with At Most Two Distinct Characters// Hash table, two pointers: sliding window problem !!!//    Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters.////    Example 1://    Input: "eceba"//    Output: 3//    Explanation: t is "ece" which its length is 3.//    Example 2://    Input: "ccaabbb"//    Output: 5//    Explanation: t is "aabbb" which its length is 5.int lengthOfLongestSubstringTwoDistinct(string s) {    unordered_map<char, int> map;    int l=s.length();    int counter=0;    int left=-1, right=-1;    int maxLength=INT_MIN;    while(right<l && left<l) {        while(right<l && left<l && counter<=2) {            ++right;            char c=s[right];            if(map.count(c)) {                                if(map[c]==0) ++counter;                map[c]++;            }            else{                map[c]=1;                ++counter;            }        }                maxLength=max(maxLength, right-left-1);                while(right<l && left<l && counter==3) {            ++left;                        --map[s[left]];            if(map[s[left]]==0) {                --counter;            }        }    }    return maxLength==INT_MIN? l:maxLength;}// simplified version:int lengthOfLongestSubstringTwoDistinct2(string s) {    unordered_map<char, int> map;    int l=s.length();    int counter=0;    int left=0, right=0;    int maxLength=INT_MIN;    while(right<l) {        while(right<=l && counter<=2) {                        if(map[s[right]]==0) ++counter;            ++map[s[right]];            ++right;        }               maxLength=max(maxLength, right-left-1);        while(left<=l && counter==3) {            --map[s[left]];            if(map[s[left]]==0) {                --counter;            }            ++left;        }    }    return maxLength==INT_MIN? l:maxLength;}// 0 ms method ???int lengthOfLongestSubstringTwoDistinct3(string s) {    int longest = 0;    int start = -1;    int c1 = -1, c2 = -1;    for (int i = 0; i < s.size(); ++i) {        if (c2 < 0 || s[i] == s[c2]) {            c2 = i;        } else if (c1 < 0 || s[i] == s[c1]) {            c1 = c2;            c2 = i;        } else {            start = c1;            c1 = c2;            c2 = i;        }                if (i - start > longest) longest = i - start;    }    return longest;}// 4 ms method???int lengthOfLongestSubstringTwoDistinct4(string s) {    unordered_map<char, int> last_occurance;    vector<char> chars;    int longest = 0;    int curr = 0;    for(int i = 0; i < s.size(); ++i){        bool skip = false;        for(int j = 0; j < chars.size(); ++j){            if(chars[j] == s[i]) skip = true;        }        if(!skip){            if(chars.size() != 2) {                chars.emplace_back(s[i]);                curr++;            } else {                char first = chars[0];                char second = chars[1];                int first_i = last_occurance[first];                int second_i = last_occurance[second];                if(first_i > second_i){                    chars[1] = s[i];                    curr = i - second_i;                } else {                    chars[0] = s[i];                    curr = i - first_i;                }                            }        } else {            curr++;        }        last_occurance[s[i]] = i;        longest = max(longest, curr);    }    return longest;}// 568. Maximum Vacation Days// DP: memorization in a matrixint maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {    int N=days.size();    if(N==0) return 0;    int K=days[0].size();    vector<vector<int>> dp(N, vector<int>(K,-1));    // 1. Initialize dp matrix.    dp[0][0]=days[0][0];    for(int i=1; i<N; ++i) dp[i][0]=flights[0][i]==1? days[i][0]:-1;    for(int i=1; i<K; ++i) {        for(int j=0; j<N; ++j) {            for(int k=0; k<N; ++k) {                if(dp[j][i-1]==-1) break;                       if(k==j ) dp[j][i]=max(dp[j][i], dp[j][i-1]+days[j][i]);                if(flights[j][k]==1) {                                        dp[k][i]=max(dp[k][i], dp[j][i-1]+days[k][i]);                }                            }        }    }    int max=INT_MIN;    for(int i=0; i<N; ++i) {        max=fmax(max,dp[i][K-1]);    }    return max;}// 687. Longest Univalue Path// Recursion, tree://    Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.////    Note: The length of path between two nodes is represented by the number of edges between them.////    Example 1://    Input://       5//      / \//     4   5//    / \   \//   1   1   5//   Output://    2struct TreeNode {    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) {}};// Helper function which helps to keep track of the longest path starting from node root.// max is the max path length so far under root.int traverse(TreeNode* root, int& max) {    // 1. Exit the recursion when root is NULL, and a NULL has length of 0, so return 0.    if(root==NULL) return 0;    // NOTE: don't add this exit condition, it makes the program much slower!!!    // if(root->left==NULL && root->right==NULL) return 0;        // 2. Call the helper function recursively for the left and right child of root.    int left= traverse(root->left, max);    int right= traverse(root->right,max);        // 3. Check if the left child and right child have the same val as the root node, if so increment the path length. If not, initialize the length to 0.    if(root->left!=NULL && root->val==root->left->val) left+=1;    else left=0;    if(root->right!=NULL && root->val==root->right->val) right+=1;    else right=0;        // 4. Update the maximum path length by adding the length from left child to the root and the length from right child to the root.    max=fmax(max,left+right);        // 5. Return the larger one between the left length and right length as the longest path length starting from the root.    return fmax(left,right);}int longestUnivaluePath(TreeNode* root) {    int max=INT_MIN;    // 1. Use the helper function to traverse the tree and find the max path.    // 2. Return the max path if max is modified. If max is not modified, return 0.    int len=traverse(root,max);    return max==INT_MIN? 0:max;}// 299. Bulls and Cows// Hash table://    You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called "bulls") and how many digits match the secret number but locate in the wrong position (called "cows"). Your friend will use successive guesses and hints to eventually derive the secret number.////    Write a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows.////    Please note that both secret number and friend's guess may contain duplicate digits.//    Example 1://    Input: secret = "1807", guess = "7810"//    Output: "1A3B"//    Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.// A very slow method:// Algorithm:// 1. Store all the positions of a char in secret in the hash table, called map.// 2. Loop through the guess, delete the position in hash table if 1 pair of char from secret and guess match, and increment count of A.// 3. If guess char does not match the secret char at the same position, add the char in guess string to a new string called notMatch.// 4. Loop again through notMatch string, and check if the char is in the map or not, if the vector that the char maps to is not empty, increment count of B, and pop the back of the vector.// 5. Return string based on the count of A and the count of B.string getHint(string secret, string guess) {    unordered_map<char, vector<int>> map;    int size=secret.size();    int a=0,b=0;    // 1.    for(int i=0; i<size; ++i) {        map[secret[i]].push_back(i);    }    bool posMatch=false;    string notMatch="";       for(int i=0; i<size; ++i) {        char c=guess[i];        if(map.count(c)) {            posMatch=false;            int mapSize=map[c].size();            for(int j=0; j<mapSize; ++j){                 // 2.                if(map[c][j]==i) {                    map[c].erase(map[c].begin()+j);                    ++a;                    posMatch=true;                    break;                }            }            // 3.            if(!posMatch)                notMatch+=c;        }    }    // 4.    for(auto c:notMatch) {        if(map[c].size()>0) {            ++b;            map[c].pop_back();        }    }    // 5.    return to_string(a)+"A"+to_string(b)+"B";}// My improved version, a much faster solution:// using hash table mapping char to int of appearance counts.// Algorithm:// 1. Loop through all char in secret, guess string to see if there is char matching at the same postion. If so, erase that char from secret and guess, increment the count of A.// 2. Loop through the secret string, store all the char left in secret in a hash table, map, with the count of the char.// 3. Loop through the guess string, and check if the count that char in guess maps to is > 0, if so, increment the count of B, and decrement the count in hash table (indicating used).// 4. Return string based on the count of A and the count of B.string getHint2(string secret, string guess) {    unordered_map<char, int> map;    int a=0,b=0;    // 1.    // NOTE: the bound of for loop (secret.size()) shoud be updated every loop, since there might be char erased from the string.    for(int i=0; i<secret.size(); ++i) {        if(secret[i]==guess[i]) {            ++a;            secret.erase(secret.begin()+i);            guess.erase(guess.begin()+i);            // NOTE: remember to move the pointer back since we erase the char at index i and move towards the rest of the string.            --i;        }    }    // 2.    for(auto c:secret) {        ++map[c];    }    // 3.    for(auto c:guess) {        if(map[c]!=0) {            ++b;            --map[c];        }    }    // 4.    return to_string(a)+"A"+to_string(b)+"B";}// 766. Toeplitz Matrix (easy)// Array: (one pass)//    A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.//    Now given an M x N matrix, return True if and only if the matrix is Toeplitz.////    Example 1://    Input://    matrix = [//              [1,2,3,4],//              [5,1,2,3],//              [9,5,1,2]//              ]//    Output: Truebool isToeplitzMatrix(vector<vector<int>>& matrix) {    int row=matrix.size();    if(row==0) return true;    int col=matrix[0].size();    for(int i=1; i<row; ++i) {        for(int j=1; j<col; ++j) {            if(matrix[i][j]!=matrix[i-1][j-1]) return false;        }    }    return true;}// 489. Robot Room Cleaner (hard)// Classic DFS using recursion://    Given a robot cleaner in a room modeled as a grid.//    Each cell in the grid can be empty or blocked.//    The robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.//    When it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.//    Design an algorithm to clean the entire room using only the 4 given APIs shown below.////    interface Robot {//        // returns true if next cell is open and robot moves into the cell.//        // returns false if next cell is obstacle and robot stays on the current cell.//        boolean move();////        // Robot will stay on the same cell after calling turnLeft/turnRight.//        // Each turn will be 90 degrees.//        void turnLeft();//        void turnRight();////        // Clean the current cell.//        void clean();//    }//    Example:////    Input://    room = [//            [1,1,1,1,1,0,1,1],//            [1,1,1,1,1,0,1,1],//            [1,0,1,1,1,1,1,1],//            [0,0,0,1,0,0,0,0],//            [1,1,1,1,1,1,1,1]//            ],//    row = 1,//    col = 3////    Explanation://    All grids in the room are marked by either 0 or 1.//    0 means the cell is blocked, while 1 means the cell is accessible.//    The robot initially starts at the position of row=1, col=3.//    From the top left corner, its position is one row below and three columns right.// 8 ms method:class Solution {public:    // NOTE: the order of this doesn't matter, make sure turning right:    // right, down, left, up    int deltaR[4]={0,1,0,-1};    int deltaC[4]={1,0,-1,0};    void dfs(Robot &robot, unordered_set<string>& visited, int r, int c, int dir) {        string s=to_string(r)+","+to_string(c);        // 1. Check if the position with r and c is visited or not. If it is visited, exit the recursion.        if(visited.count(s)) return;        // 2. Clean the current position, add the current position to the hash table.        robot.clean();        visited.insert(s);        // 3. Do dfs for all 4 directions,               for(int i=0; i<4; ++i) {            // (1) calculate a new direction based on the current direction (dir),            int newDir=(dir+i)%4;            // (2) if we can not move in the current direction, turn right and go to the next newDir(which is the right direction of the last newDir).            if(!robot.move()){                robot.turnRight();                continue;            }            // (3) call dfs recursively for the next position after 1 move in newDir.            dfs(robot, visited, r+deltaR[newDir], c+deltaC[newDir], newDir);            // (4) Move back to the old position as p indicated.            robot.turnRight();            robot.turnRight();            robot.move();            // (5) Turn to the next direction, which is the right of the old direction.            // NOTE: since we are move back, we are facing the back of the old direction. Therefore, turning left is turning to the right direction of the last newDir direction.            robot.turnLeft();        }            }        void cleanRoom(Robot& robot) {        // 1. Use hash map with string as key to store visited positions.        unordered_set<string> visited;        // 2. Use dfs to search from the (0,0) position.        dfs(robot, visited, 0, 0, 0);            }};    // LeetCode 4 ms solution:// IDEA://    The basic idea is each cleanRoom call explore all 4 directions from the current location and exit with same state before the cleanRoom call (means the same location and the same direction)////    Use a hashmap to terminate, no need to explore locations visted.        class Solution {    public:        unordered_map<int, unordered_map<int, int>> data;        int x=0;        int y=0;        int dx[4]={1, 0, -1, 0};        int dy[4]={0, 1, 0, -1};        int dir=0;        void cleanRoom(Robot& robot) {            if(data[x][y]==1){                return;            }            data[x][y]=1;            robot.clean();            for(int i=0; i<4; i++){                if(robot.move()){                    x+=dx[dir];                    y+=dy[dir];                    cleanRoom(robot);                    robot.turnRight();                    robot.turnRight();                    robot.move();                    robot.turnRight();                    robot.turnRight();                    x-=dx[dir];                    y-=dy[dir];                }                robot.turnRight();                dir=(dir+1)%4;            }        }    };// 418. Sentence Screen Fitting// DP: still not sure what the method is?//    Given a rows x cols screen and a sentence represented by a list of non-empty words, find how many times the given sentence can be fitted on the screen.////    Note://    A word cannot be split into two lines.//    The order of words in the sentence must remain unchanged.//    Two consecutive words in a line must be separated by a single space.//    Total words in the sentence won't exceed 100.//    Length of each word is greater than 0 and won't exceed 10.//    1 ≤ rows, cols ≤ 20,000.//    Example 1://    Input://    rows = 2, cols = 8, sentence = ["hello", "world"]//    Output://    1//    Explanation://    hello---//    world---int wordsTyping(vector<string>& sentence, int rows, int cols) {    int size=sentence.size();    // 1. Build a new string s with all the words in sentence, and " " in between each 2 words, and " " at the end. ( - shows the space)    // EX: hello-world-    string s;    // 2. Loop through the entire space padded multiple sentences string, and fit the starting position of the next row.    // EX: hello-world-hello-world-hello-world- ...    for(int i=0; i<size; ++i) {        s+=(sentence[i]+" ");    }    int start=0;    int l=s.length();    for(int i=0; i<rows; ++i) {        // Try to find the the first letter of a word (which has ' ' before it) within the range of last start + cols as the starting position/index in the space padded string s for the next row.        start+=cols;        if(s[start%l]==' ') ++start;        else {            while(start>0 && s[(start-1)%l]!=' ') --start;        }    }    // 3. Return how many times start position in the multiple sentences string can loop through one entire sentence.    return (start)/(l);}// 616. Add Bold Tag in String// String: (KMP)//    Given a string s and a list of strings dict, you need to add a closed pair of bold tag <b> and </b> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them.//    Example 1://    Input://    s = "abcxyz123"//    dict = ["abc","123"]//    Output://    "<b>abc</b>xyz<b>123</b>"//    Example 2://    Input://    s = "aaabbcc"//    dict = ["aaa","aab","bc"]//    Output://    "<b>aaabbc</b>c"// Fastest 12 ms method: using mask (vector<int>) to store wether a char in string s is bolded or not.class Solution {public:    string addBoldTag(string s, vector<string>& dict) {        if (dict.empty() || s.empty()) return s;        int size=s.size();        // 1. Use a vector of integer as mask with the same size as the length of string s to store the information of wether a char is visited by the words in dict (should be bolded). 0 indicates not bolded, 1 indicateds bolded.        vector<int> bolded(size + 1, 0);        // 2. Loop through the dict vector to build the mask, bolded, and fill the vector bolded with 1 from the start position, s.find(word, begin), to the end position of all word in string s.        for (auto word: dict) {            // NOTE: Use begin as a start point of next s.find() to find all the substrings that is the same as word.            size_t begin = 0;            while (begin < size) {                begin = s.find(word, begin);                if (begin == string::npos) break;                fill(bolded.begin() + begin, bolded.begin() + begin + word.size(), 1);                ++ begin;            }        }        string result = "";        // 3. Loop through the mask indicating wether a char in s has been bolded or not, and build the result string with "<b>" and "</b>".        // or size_t        // NOTE: the bound is i <= size since we want to check if there should be a "</b>" at the end of string result.        for (int i = 0; i <= size; ++i) {            // (1) Add "<b>" if the first char is bolded            if (i == 0) {                if (bolded[i] == 1) result += "<b>";            }            else {                // (2) Add "<b>" indicating the start of a bold substring, if the current char should be bolded, and the last char should not be bolded.                if (bolded[i] == 1 && bolded[i - 1] == 0) result += "<b>";                // (3) Add "</b>" indicating the end of a bold substring, if the current char should not be bolded, and the last char is bolded.                if (bolded[i] == 0 && bolded[i - 1] == 1) result += "</b>";            }            // (4) Append current char to the current result string if i is in bound. Make sure i < size, don't append the char outside size-1.            if (i < size) result += s[i];        }        // 4. Return the result string.        return result;    }};// 135. Candy//    There are N children standing in a line. Each child is assigned a rating value.////    You are giving candies to these children subjected to the following requirements:////    Each child must have at least one candy.//    Children with a higher rating get more candies than their neighbors.//    What is the minimum candies you must give?////    Example 1://    Input: [1,0,2]//    Output: 5//    Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.//    Example 2://    Input: [1,2,2]//    Output: 4//    Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.//    The third child gets 1 candy because it satisfies the above two conditions.// My greedy algorithm:// 1. Initialize all the value in the vector children (which indicates how many candies a child will get) to 1.// 2. Loop from left to right through ratings vector. Look at 2 elements in the vector at a time.//      (1) if R1 > R2//              if C1 <= C2, C1 = C2 + 1//      (2) if R1 < R2//              if C2 <= C1, C2 = C1 + 1// 3. Loop from right to left through ratings vector again.// 4. Sum up all elements in children vector to get the total # of candies.int candy(vector<int>& ratings) {    int size=ratings.size();    // 1.    vector<int> children(size,1);    // 2.    for(int i=1; i<size; ++i) {        // (1)        if(ratings[i-1]>ratings[i]) {            if(children[i-1]<=children[i])                children[i-1]=children[i]+1;        }        // (2)        else if(ratings[i-1]<ratings[i]) {            // NOTE: Don't write it like this, this while loop will damage the speed!!!            //while(children[i]<=children[i-1]) ++children[i];            if(children[i]<=children[i-1])                children[i]=children[i-1]+1;        }    }    // 3.    for(int i=size-2; i>=0; --i) {        if(ratings[i]>ratings[i+1]) {            if(children[i]<=children[i+1])                children[i]=children[i+1]+1;        }        else if(ratings[i]<ratings[i+1]) {            if(children[i+1]<=children[i])                children[i+1]=children[i]+1;        }    }    // 4.    int result=0;    for(auto c:children) {        result+=c;    }    return result;}// The same, but shorter version:int candy(vector<int>& ratings) {    int size=ratings.size();    // 1. Initialize all the value in the vector children (which indicates how many candies a child will get) to 1.    vector<int> children(size,1);    // 2. Loop from left to right through ratings vector. Look at 2 elements in the vector at a time.    for(int i=1; i<size; ++i) {        // (1) if R1 > R2        //       if C1 <= C2, C1 = C2 + 1        if(ratings[i-1]>ratings[i] && children[i-1]<=children[i])            children[i-1]=children[i]+1;        // (2) if R1 < R2        //        if C2 <= C1, C2 = C1 + 1        else if(ratings[i-1]<ratings[i] && children[i]<=children[i-1])        // NOTE: Don't write it like this, this while loop will damage the speed!!!            //while(children[i]<=children[i-1]) ++children[i];            children[i]=children[i-1]+1;    }    // 3. Loop from right to left through ratings vector again.    for(int i=size-2; i>=0; --i) {        if(ratings[i]>ratings[i+1] && children[i]<=children[i+1])            children[i]=children[i+1]+1;        else if(ratings[i]<ratings[i+1] && children[i+1]<=children[i])            children[i+1]=children[i]+1;    }    // 4. Sum up all elements in children vector to get the total # of candies.    int result=0;    for(auto c:children) {        result+=c;    }    return result;}



Google (2)// 49. Group Anagrams// Hash table:// Method 1: Sort the word, use the sorted string as the key of hash table. Use map from string to multiset that store all the words that the same string maps to.vector<vector<string>> groupAnagrams(vector<string>& strs) {    // NOTE: use of multiset: when we want to map a string to    // set和multiset会根据特定的排序原则将元素排序。两者不同之处在于，multisets允许元素重复，而set不允许重复。sets和multisets通常以平衡二叉树完成    unordered_map<string, multiset<string>> map;    for (string s : strs) {        string temp = s;        sort(temp.begin(), temp.end());        map[temp].insert(s);    }    vector<vector<string>> anagrams;    for (auto m : map) {        vector<string> anagram(m.second.begin(), m.second.end());        anagrams.push_back(anagram);    }    return anagrams;}// Method 2: Instead of multiset, we can use vector to store all the anagrams that the same key maps to.// Same speed as method 1:vector<vector<string>> groupAnagrams(vector<string>& strs) {    unordered_map<string, vector<string>> map;    for (string s : strs) {        string temp = s;        sort(temp.begin(), temp.end());        map[temp].push_back(s);    }    vector<vector<string>> anagrams;    for (auto m : map) {        vector<string> anagram(m.second.begin(), m.second.end());        anagrams.push_back(anagram);    }    return anagrams;}// 22. Generate Parentheses// Backtracking: (an application of dfs)//    Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.////    For example, given n = 3, a solution set is:////    [//     "((()))",//     "(()())",//     "(())()",//     "()(())",//     "()()()"//     ]// cout output://    string:(//    open+1:1//    close:0//    string:((     <-------- return back to here//    open+1:2//    close:0//    string:(((//    open+1:3//    close:0//    string:((()//    open:3//    close+1:1//    string:((())//    open:3//    close+1:2//    string:((()))//    open:3//    close+1:3//    complete:((()))// pop off the last entered '('//    string:(()     <--------return back to here//    open:2//    close+1:1//    string:(()(//    open+1:3//    close:1//    string:(()()//    open:3//    close+1:2//    string:(()())//    open:3//    close+1:3//    complete:(()())////    string:(())      <----- this is at the end of that func, return back to last level//    open:2//    close+1:2//    string:(())(//    open+1:3//    close:2//    string:(())()//    open:3//    close+1:3//    complete:(())()//    string:()//    open:1//    close+1:1//    string:()(      <--------return back to here//    open+1:2//    close:1//    string:()((//    open+1:3//    close:1//    string:()(()//    open:3//    close+1:2//    string:()(())//    open:3//    close+1:3//    complete:()(())//    string:()()//    open:2//    close+1:2//    string:()()(//    open+1:3//    close:2//    string:()()()//    open:3//    close+1:3//    complete:()()()// Backtracking is a application of dfs, which generate the final permutation from the start making choices in each step.// DFS helper function:void backtrack(vector<string>& result, string str, int open, int close, int n){    // 1. Exit if the string that holds the permutation reaches n * 2, and push the string str back to the result vector.    if(str.length() == n*2){        result.push_back(str);        return;    }    // 2. Explore the left child, or choose to place a '(' in the next position if we can.    // The valid condition for placing a '(' is that the total count of '(' is < n.    if(open < n){        backtrack(result, str+'(', open+1, close, n);    }    // 3. Explore the right child, or choose to place a ')' in the next position if we can.    // The valid condition for placing a ')' is that the total count of ')' is < total count of '('. (There is open parenthesis available that haven't been closed by ')').    if(close < open) {        backtrack(result, str+')', open, close+1, n);    }}vector<string> generateParenthesis(int n) {    vector<string> result;    string s="";    // s: the current permutation.    // open: total count of '(' in s.    // close: total count of ')' in s.    backtrack(result, s, 0, 0, n);    return result;}// 224. Basic Calculator// Math, stack://    Implement a basic calculator to evaluate a simple expression string.////    The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .////  Example 1://    Input: "1 + 1"//    Output: 2//  Example 2://    Input: " 2-1 + 2 "//    Output: 3//  Example 3://    Input: "(1+(4+5+2)-3)+(6+8)"//    Output: 23int calculate(string s) {    // 1. Use 2 stacks of int, nums stores the previous sum when we have '(' which means we have a following parenthesis, ops stores the sign before this following parenthesis.    stack<int> nums, ops;    int sign=1;    int num=0;    int result=0;    // 2. Loop through all the char in string s, and continue if char is space.    for(auto c : s) {        if(c==' ') continue;        // (1) If the current char is digit, add it to the sum of current number.        if(isdigit(c)) {            num = num * 10 + c - '0';            //cout<<"num:"<<num<<"\n";        }        // (2) If the current char is not a digit, which means the end of a number, add or subtract the number to result based on the value of sign. Clear the current number.        //  - if c is '+', change sign to +1.        //  - if c is '-', change sign to -1.        //  - if c is '(', push result to stack nums, and push the closest sign before '(' to stack ops. Clear result, and initialize sign back to +1.        //  - if c is ')', add the result value * top of ops stack to the top of nums stack, which is the last result number before the current parenthesis. Store this value to result. Pop nums top, and pop ops top.        else {            result += num * sign;            num=0;            if(c=='+') sign=1;            else if(c=='-') sign=-1;            else if(c=='(') {                nums.push(result);                ops.push(sign);                result=0;                sign=1;            }            else if(c==')' && !nums.empty()) {                result = result*ops.top() + nums.top();                nums.pop(); ops.pop();                //nums.push(result); // NOTE: don't add the result back to stack!!!                //cout<<"result:"<<result<<"\n";            }        }    }    // 3. Return the value after adding or subtracting the last num to result based on the last sign.    return result+sign*num;}// cout output://    num:1//    num:4//    num:5//    num:2//    result:12//    num:3//    result:9//    num:6//    num:8//    result:23// 289. Game of Life//    According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."////    Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):////    Any live cell with fewer than two live neighbors dies, as if caused by under-population.//    Any live cell with two or three live neighbors lives on to the next generation.//    Any live cell with more than three live neighbors dies, as if by over-population..//    Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.//    Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.////  Example://    Input://    [//     [0,1,0],//     [0,0,1],//     [1,1,1],//     [0,0,0]//     ]//    Output://    [//     [0,0,0],//     [1,0,1],//     [0,1,1],//     [0,1,0]//     ]// Follow up://    Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.//    In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?// Helper function to count how many alive cells are within the neighbors of cell at (i, j)int liveNeighbors(vector<vector<int>> board, int m, int n, int i, int j) {    int count=0;    // 1. Check all cells in the squre with 9 nodes including all neighbors of (i, j) and (i, j) itself. (if (i, j) is at the border, reduce the size of the squre according to the boundary.    for(int a=fmax(i-1, 0); a<=fmin(i+1, m-1); ++a) {        for(int b=fmax(j-1, 0); b<=fmin(j+1, n-1); ++b)            // 2. Increment count if the last bit of the cell is 1 (the original value of the cell is 1).            // NOTE: only check wether the last bit is 1 or 0!!!            if(board[a][b] & 1 == 1) ++count;            }    // 3. Check if (i, j) has last bit as 1, if so decrement count since we don't want to count the cell (i, j).    // NOTE: need to decrement count by 1 if the center is alive (last bit is 1).    if(board[i][j] & 1 == 1) --count;    return count;}void gameOfLife(vector<vector<int>>& board) {    if ( board.size() == 0 || board[0].size()==0) return;    int m = board.size(); // # of rows    int n = board[0].size(); // # of cols        // 1. Loop through all the nodes in the 2D array, check the number of alive neighbors of all nodes.    for (int i = 0; i < m; ++i) {        for (int j = 0; j < n; ++j) {            // 2. Use the helper function to check the number of alive neighbors of node (i, j).            int lives = liveNeighbors(board, m, n, i, j);                        // In the beginning, every 2nd bit is 0;            // So we only need to care about when will the 2nd bit become 1.            // 3. Condition that the cell will be alive in the next round:            //  - If the original value of board[i][j] is 1 (alive), and has 2 or 3 live neighbors, modify the second bit of board[i][j] to 1.            //  - If the original value of board[i][j] is 0 (die), and has 3 live neighbors, modify the second bit of board[i][j] to 1.            if (board[i][j] == 1 && lives >= 2 && lives <= 3) {                board[i][j] = 3; // Make the 2nd bit 1: 01 ---> 11            }                        if (board[i][j] == 0 && lives == 3) {                board[i][j] = 2; // Make the 2nd bit 1: 00 ---> 10            }            // 4. All other conditions will result in 0 in board[i][j] in the next round after we shift board[i][j] to the right by 1.        }    }    // 5. Loop through all nodes on board, shift the value to the right by 1.    for (int i = 0; i < m; ++i) {        for (int j = 0; j < n; ++j) {                        board[i][j] = board[i][j] >> 1;  // Get the 2nd state.        }    }}int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}