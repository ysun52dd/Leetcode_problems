Binary Search//  binary search////  Created by SunYutong on 7/3/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <cmath>using namespace std;/* * @param A: An integers array. * @return: return any of peek positions. */int findPeakElement(vector<int>& A) {    // write your code here    //find the middle:    //if the middle is incline, peak is on the right    //if the middle is decline, peak is on the left    //if the middle is a peak, return it    //if the middle is a trough, there are peaks on both left and right    int start = 0;    int size=(int)A.size();        int end = size-1;    if(size==1)        return 0;            while(start+1 < end) {        int mid = start+(end - start)/2;                if ((A[mid+1]>A[mid]) && (A[mid] > A[mid-1])){            //if the middle is incline, peak is on the right            start = mid;        }                else if((A[mid+1]<A[mid]) && (A[mid+1] > A[mid-1])){            return mid;                    }else {            end = mid;        }    }    if(A[start]<A[end]){        return end;    }else {        return start;    }}//153. Find Minimum in Rotated Sorted Array//Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.//(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).////Find the minimum element.////You may assume no duplicate exists in the array.////Example 1:////Input: [3,4,5,1,2]//Output: 1//Example 2:////Input: [4,5,6,7,0,1,2]//Output: 0int findMin(vector<int>& nums) {    int start = 0;    int size=(int)nums.size();        int end = size-1;    if(size==1)        return nums[start];            while(start+1 < end) {        int mid = start+(end - start)/2;                if (nums[mid]>nums[start] && nums[mid]>nums[end]){            //if the middle is before the min and the array is rotated (not sorted like [1,2,3])            start = mid;        }                else {            end=mid;                    }    }    if(nums[start]<nums[end] ){        return nums[start];    }else {        return nums[end];    }    }//69. Sqrt(x)//Implement int sqrt(int x).////Compute and return the square root of x, where x is guaranteed to be a non-negative integer.////Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.////Example 1:////Input: 4//Output: 2//Example 2:////Input: 8//Output: 2//Explanation: The square root of 8 is 2.82842..., and since//the decimal part is truncated, 2 is returned.int mySqrt(int x) {    if(x==1)        return 1;    if(x==0)        return 0;    int start=0;    int end=x;        while(start+1 < end) {        int mid = start+(end-start)/2;                if ((mid*mid)<=x){                        start = mid;        }                else {            end=mid;                    }    }    if((start*start)<=x){        return start;    }else {        return end;    }}//lintcode: 183. Wood Cutlong int count(vector<int> &L, long int length){    long int sum =0;    for (int i = 0; i<L.size(); i++)    {        sum += L[i] / length;    }    return sum;}int woodCut(vector<int> &L, int k) {    // write your code here    if(count(L, 1)<k)        return 0;    long int max=0;    for(int i=0; i<L.size(); i++)    {        max=fmax(max, L[i]);    }    long int start=0;    long int end=max;        while(start+1 < end) {        //int mid = start+(end - start)/2;        long int mid = (start + end)/2;                if (count(L, mid)>=k){                        start = mid;        }                else {            end=mid;                    }    }    if(count(L, start) >= k){        return (int)start;    }if(count(L, end) >= k) {        return (int)end;    }else        return 0;}//helper function for copyBookesint countCopiers(vector<int> &pages, int limit){    if(pages.size()==0)        return 0;    int copiers = 1;    int sum = pages[0];    for (int i=1; i<pages.size(); i++)    {        if(sum + pages[i] > limit){        copiers++;        sum = 0;        }        sum += pages[i];    }    return copiers;    }//lintcode: 437. Copy Booksint copyBooks(vector<int> &pages, int k) {    // write your code here    if(pages.size()==0)        return 0;    int total=0;    int max = pages[0];    for (int i=0; i<pages.size(); i++)    {        total += pages[i];        if(max<pages[i])            max=pages[i];            }    int start = max;    int end = total;    while(start+1 < end) {        int mid = start+(end-start)/2;                //if number of copiers > k when limit is mid, limit need to be larger than mid        if (countCopiers(pages, mid)>k){                        start = mid;        }                else {            end=mid;        }    }        if(countCopiers(pages, start)<=k)            return start;        else            return end;}// 378. Kth Smallest Element in a Sorted Matrix// binary searchint kthSmallest(vector<vector<int>>& matrix, int k) {    int n=matrix.size();    int start=matrix[0][0];    int end=matrix[n-1][n-1];    int mid=0;    while(start<end)    {        mid=start+(end-start)/2;        int num=0;        for(auto n:matrix)        {            // how many elements are <= mid            int pos=upper_bound(n.begin(), n.end(), mid)-n.begin();            num+=pos;                    }        // if # of elements that are <= mid is < k, so kth element is not in the start to mid interval        if(num<k)            start=mid;        // if # of elements that are <= mid is >= k, so kth element should be in the start to mid interval        else            end=mid;    }        int num1=0;         for(auto n:matrix)         {             // how many elements are <= mid             int pos1=upper_bound(n.begin(), n.end(), start)-n.begin();             num1+=pos1;         }         if(num1>=k)         return start;     else         return end;        }// Binary search:// faster version:int kthSmallest2(vector<vector<int>>& matrix, int k) {    int n=matrix.size();    int start=matrix[0][0];    int end=matrix[n-1][n-1];    int mid=0;    while(start<end)    {        mid=start+(end-start)/2;        int num=0;        for(auto n:matrix)        {            // how many elements are <= mid            int pos=upper_bound(n.begin(), n.end(), mid)-n.begin();            num+=pos;                    }        // if # of elements that are <= mid is < k, so kth element is not in the start to mid interval        if(num<k)            start=mid+1;        // if # of elements that are <= mid is >= k, so kth element should be in the start to mid interval        else            end=mid;    }        return start;}// input://[[1,5,9],[10,11,13],[12,14,15]]//8//start:1//end:15//mid:8//num:2////start:9//end:15//mid:12//num:6////start:13//end:15//mid:14//num:8////start:13//end:14//mid:13//num:7////final start14//final end14int main(){    vector<int> input;    input={3,2,4};    int copiers=2;    int solution=copyBooks(input, copiers);    printf("%d",solution);    }