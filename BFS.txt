BFS//  Binary Search Tree////  Created by SunYutong on 7/21/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <string>#include <stdio.h>#include <math.h>#include <queue>#include <unordered_set>#include <unordered_map>using namespace std;struct TreeNode {    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) {}};// 102. Binary Tree Level Order Traversal// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).// method 1: recursionvector<vector<int>> result;void buildVector(TreeNode *root, int depth){    if(root == NULL) return;    if(result.size() == depth)        result.push_back(vector<int>());        result[depth].push_back(root->val);    buildVector(root->left, depth + 1);    buildVector(root->right, depth + 1);}vector<vector<int> > levelOrder(TreeNode *root) {    buildVector(root, 0);    return result;}// method 2: queuevector<vector<int> > levelOrder2(TreeNode *root) {        vector<vector<int>> result;        if(root==NULL){        return result;    }    queue<TreeNode*> q;    q.push(root);        while(!q.empty())    {        vector<int> level;        int size=(int)q.size();        for(int i=0; i<size; i++)        {            TreeNode* node=q.front();            q.pop();            level.push_back(node->val);            if(node->left!=NULL)                q.push(node->left);            if(node->right!=NULL)                q.push(node->right);        }        result.push_back(level);    }    return result;}// linkcode: 7. Serialize and Deserialize Binary Treestring serialize(TreeNode * root) {    // write your code here    string result={};        if(root==NULL){        return "{}";    }    queue<TreeNode*> q;    q.push(root);    //result+=to_string(root->val);    result+="{";        while(!q.empty())    {        //vector<int> level;        int size=(int)q.size();        for(int i=0; i<size; i++)        {            TreeNode* node=q.front();            q.pop();            if(node!=NULL)            {                if(node!=root){                result+=",";                }                result+=to_string(node->val);                q.push(node->left);                q.push(node->right);            }            else                result+=",#";        }    }    result+="}";    return result;}// split a string with delim dividing string elements into a vector of stringsvector<string> split(const string &str, string delim) {    vector<string> results;    int lastIndex = 0, index;    while ((index = str.find(delim, lastIndex)) != string::npos) {        results.push_back(str.substr(lastIndex, index - lastIndex));        lastIndex = index + delim.length();    }        if (lastIndex != str.length()) {        results.push_back(str.substr(lastIndex, str.length() - lastIndex));    }        return results;}TreeNode *deserialize(string data) {    if (data == "{}") {        return NULL;    }        vector<string> vals = split(data.substr(1, data.size() - 2), ",");    TreeNode *root = new TreeNode(atoi(vals[0].c_str()));    queue<TreeNode *> Q;    Q.push(root);        bool isLeftChild= true;    for (int i = 1; i < vals.size(); i++) {        if (vals[i] != "#") {            TreeNode *node = new TreeNode(atoi(vals[i].c_str()));            if (isLeftChild) {                Q.front()->left = node;            } else {                Q.front()->right = node;            }            Q.push(node);        }        if (!isLeftChild) {            Q.pop();        }                isLeftChild = !isLeftChild;    }    return root;}//TreeNode * deserialize(string &data) {//    // write your code here//    queue<TreeNode*> q;//    char * c=&data[0];//    TreeNode* root=new TreeNode(atoi(c));//    //sscanf(data, "%d,", node->val);//    //TreeNode node(atoi(&data[0]));//    q.push(root);//    //TreeNode* result=&node;//    //int level=1;//    while(!data.empty())//    {//        //vector<int> level;////        int size=(int)q.size();//        for(int i=0; i<size; i++)//        {//            TreeNode* node=q.front();//            q.pop();////            TreeNode node(atoi(&data[2+2*i]));////            q.push(&node);////            if(node!=NULL)////                result=result+","+to_string(node->val);////            else////                result+=",#";//            //level.push_back(node->val);//        if(node->left!=NULL){//                //q.push(node->left);//                TreeNode* left=new TreeNode(atoi(c));////        }//            else//                q.push(NULL);//            if(node->right!=NULL)//                q.push(node->right);//            else//                q.push(NULL);//        }////    }//    return root;//}// lintcod: 178. Graph Valid Treebool validTree(int n, vector<vector<int>> &edges) {    // write your code here    // calculate number of edges and number of nodes, and verify that the graph has n nodes and n-1 edges        if(n==0)        return false;    if(edges.size()!=n-1)        return false;    // vector constructor!!!!!!!!!    vector<unordered_set<int>> g(n, unordered_set<int>());    unordered_set<int> v;    queue<int> q;    // then start from one node,node 0, check if we can visit all n nodes    q.push(0);    v.insert(0);    // use a vector of unordered_set g to store all neighbors of a node into unordered_set with an index of the node    for (auto a : edges) {        g[a.front()].insert(a.back());        g[a.back()].insert(a.front());    }    // use bfs to visit all nodes, put visited nodes into an unordered_set v    while (!q.empty()) {        int t = q.front(); q.pop();        for (auto a : g[t]) {            if (v.find(a) != v.end()) return false;            v.insert(a);            q.push(a);            g[a].erase(t);        }    }    return v.size() == n;}// 261. Graph Valid Tree// **************** need to remember!!! *****************bool validTree(int n, vector<pair<int, int>>& edges) {        // 1. calculate number of edges and number of nodes, and verify that the graph has n nodes and n-1 edges    // 2. then start from one node, check if we can visit all n nodes    if(n==0)        return false;    // 1.    if(edges.size()!=n-1)        return false;    // 2.    // graph g    vector<unordered_set<int>> g(n, unordered_set<int>());    // set to store all visited node    unordered_set<int> v;    // queue with nodes to be explored    queue<int> q;    // start from node 0    q.push(0);    v.insert(0);    // loop through all edges to be the graph (g with an unordered_set of all neighbors of a node indicated by index of g)    for (auto a : edges) {        g[a.first].insert(a.second);        g[a.second].insert(a.first);    }    while (!q.empty()) {        int t = q.front(); q.pop();        // loop through all neighbors of node t        for (auto a : g[t]) {            // if neighbor a is visited before, there is a cycle, not a tree            if (v.find(a) != v.end()) return false;            //            v.insert(a);            q.push(a);            // remove node t on the other side of the same edge, remove node t in neighbors of a            g[a].erase(t);        }    }    return v.size() == n;    }// 133. Clone Graph//Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.//We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.//As an example, consider the serialized graph {0,1,2#1,2#2,2}.////The graph has a total of three nodes, and therefore contains three parts as separated by #.////First node is labeled as 0. Connect node 0 to both nodes 1 and 2.//Second node is labeled as 1. Connect node 1 to node 2.//Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.//Visually, the graph looks like the following:////  1// / \///   \//0 --- 2//     / \//     \_/struct UndirectedGraphNode {    int label;    vector<UndirectedGraphNode *> neighbors;    UndirectedGraphNode(int x) : label(x) {};};UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {    if (node==NULL)        return NULL;    // use bfs to traverse all nodes on the graph    UndirectedGraphNode *p1 = node;    UndirectedGraphNode *p2 = new UndirectedGraphNode(node->label);    unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> map;    queue<UndirectedGraphNode*> q;    q.push(node);    map[node] = p2;        while(!q.empty()) {        // pop a node in queue into pointer p1        // map p2 to p1        p1 = q.front(); p2 = map[p1];        q.pop();        for(auto neighbor : p1->neighbors) {            UndirectedGraphNode *nb = neighbor;            // if we alreay visited neighbor nb            // push            if(map.count(nb)) {                p2->neighbors.push_back(map[nb]);            } else { // copy all the nodes and map the old nodes to their copied versions                // creat a new node, and copy the old node                UndirectedGraphNode *temp = new UndirectedGraphNode(nb->label);               // add neighbors(edges) in the new graph                // copy neighbors (edges)                p2->neighbors.push_back(temp);                // map old node to new node                map[nb] = temp;                q.push(nb);            }        }    }        return map[node];}// java:// UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {//    if (node == null) {//        return node;//    }////    // use bfs algorithm to traverse the graph and get all nodes.//    ArrayList<UndirectedGraphNode> nodes = getNodes(node);////    // copy nodes, store the old->new mapping information in a hash map//    HashMap<UndirectedGraphNode, UndirectedGraphNode> mapping = new HashMap<>();//    for (UndirectedGraphNode n : nodes) {//        mapping.put(n, new UndirectedGraphNode(n.label));//    }////    // copy neighbors(edges)//    for (UndirectedGraphNode n : nodes) {//        UndirectedGraphNode newNode = mapping.get(n);//        for (UndirectedGraphNode neighbor : n.neighbors) {//            UndirectedGraphNode newNeighbor = mapping.get(neighbor);//            newNode.neighbors.add(newNeighbor);//        }//    }////    return mapping.get(node);//}//// ArrayList<UndirectedGraphNode> getNodes(UndirectedGraphNode node) {//    Queue<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();//    HashSet<UndirectedGraphNode> set = new HashSet<>();////    queue.offer(node);//    set.add(node);//    while (!queue.isEmpty()) {//        UndirectedGraphNode head = queue.poll();//        for (UndirectedGraphNode neighbor : head.neighbors) {//            if(!set.contains(neighbor)){//                set.add(neighbor);//                queue.offer(neighbor);//            }//        }//    }////    return new ArrayList<UndirectedGraphNode>(set);//}// lintcode: 127. Topological Sorting//Given an directed graph, a topological order of the graph nodes is defined as follow:////For each directed edge A -> B in graph, A must before B in the order list.//The first node in the order can be any node in the graph with no nodes direct to it.//Find any topological order for the given graph.struct DirectedGraphNode {        int label;        vector<DirectedGraphNode *> neighbors;        DirectedGraphNode(int x) : label(x) {};    };//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!// Function to get indegree of all nodes in a graphunordered_map<DirectedGraphNode*, int> getIndegree(vector<DirectedGraphNode*>& graph) {    unordered_map<DirectedGraphNode*, int> indegree;    // initialize unordered_map indegree    for(auto node : graph)        indegree[node]=0;    for(auto node : graph)    {        for(auto neighbor : node->neighbors)        {            // node -> neighbor            // increase the indegree of neighbor            indegree[neighbor]++;        }    }    return indegree;}vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*>& graph) {    // write your code here    vector<DirectedGraphNode*> order;    if(graph.empty())        return order;    // 1. count indegree using unordered_map (Map using HashMap in java)    unordered_map<DirectedGraphNode*, int> indegree=getIndegree(graph);        // 2. Topological sort    queue<DirectedGraphNode*> q;    for(auto node : graph)    {        if(indegree[node]==0) {            q.push(node);        }    }    while (!q.empty()) {        // explore one node in queue with 0 indegree        DirectedGraphNode* node=q.front();        q.pop();        // put explored node into topological sort order        order.push_back(node);        for(auto neighbor : node->neighbors)        {            // node->neighbor            indegree[neighbor]--;            if(indegree[neighbor]==0)                q.push(neighbor);        }    }// If the graph contains cycle://    if(indegree.size()==graph.size())//        return order;//    else//    {//        vector<DirectedGraphNode*> emptyOrder;//        return emptyOrder;//    }        return order;}// 200. Number of Islands//Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.class Coordinate {public:    int x, y;    Coordinate(int x, int y) {        this->x = x;        this->y = y;    }};bool inBound(vector<vector<char>>& grid, Coordinate c){    int n = grid.size(); // # of rows    int m = grid[0].size(); //# of columns    return c.x>=0 && c.x<n && c.y>=0 && c.y<m;    }void markByBFS(vector<vector<char>>& grid, int x, int y){    // up down left right    int directionX[]={0, 1, -1, 0};    int directionY[]={1, 0, 0, -1};        queue<Coordinate> q;    q.push(Coordinate(x,y));    grid[x][y]='0';        while(!q.empty())    {        Coordinate c=q.front();        q.pop();        for(int i=0; i<4; i++)        {            // calculate the adjacent coordinate            Coordinate adj=Coordinate(c.x+directionX[i], c.y+directionY[i]);            // skip the check if adjacent point is out of bound            if(!inBound(grid, adj))                continue;            // if the adjacent point is 1, switch it to 0 and push it to queue            if(grid[adj.x][adj.y]=='1')            {                grid[adj.x][adj.y]='0';                q.push(adj);            }        }    }}int numIslands(vector<vector<char>>& grid) {    if (grid.size() == 0 || grid[0].size() == 0) {        return 0;    }    int n = grid.size(); // # of rows    int m = grid[0].size(); //# of columns    int island=0;    for(int i=0; i<n; i++)    {        for(int j=0; j<m; j++)        {            if(grid[i][j]=='1')            {                markByBFS(grid, i, j);                island++;            }                    }            }    return island;}// lintcode: 611. Knight Shortest Path// Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route. Return -1 if knight can not reached.struct Point {    int x;    int y;    Point() : x(0), y(0) {}    Point(int a, int b) : x(a), y(b) {}};struct Steps {    Point p;    int s;    Steps() : p(), s(0) {}    Steps(Point a, int b) : p(a), s(b) {}};bool isInBound(vector<vector<bool>>& grid, Point p){    int n = grid.size(); // # of rows    int m = grid[0].size(); //# of columns    return p.x>=0 && p.x<n && p.y>=0 && p.y<m;    }void useBFS(vector<vector<bool>>& grid, int x, int y){    // 8 possible moves    int directionX[]={1, 1, -1, -1, 2, 2, -2, -2};    int directionY[]={2, -2, 2, -2, 1, -1, 1, -1};        queue<Point> q; // queue of points    queue<int> step; // step so far    q.push(Point(x,y));    step.push(0);    while(!q.empty())    {        Point p=q.front();        int s=step.front();        q.pop();        step.pop();        for(int i=0; i<8; i++)        {            // calculate point of next step            Point adj=Point(p.x+directionX[i], p.y+directionY[i]);            if(!isInBound(grid, adj))                continue;            // if point of next step is 0            if(!grid[adj.x][adj.y])            {                //grid[adj.x][adj.y]='0';                q.push(adj);                step.push(s+1);            }                   }    }}int shortestPath(vector<vector<bool>> &grid, Point &source, Point &destination) {    if (grid.size() == 0 || grid[0].size() == 0) {        return 0;    }    // 8 possible moves    int directionX[]={1, 1, -1, -1, 2, 2, -2, -2};    int directionY[]={2, -2, 2, -2, 1, -1, 1, -1};    int steps=0;    queue<Point> q; // queue of points    //queue<int> step; // step so far    q.push(source);    //step.push(0);    //bool first=true;        while(!q.empty())    {        int size=q.size();                for(int i=0;i<size; i++){        Point p=q.front();        //int s=step.front();        q.pop();        //step.pop();                if(p.x==destination.x && p.y==destination.y)        {            return steps;        }                    for(int i=0; i<8; i++)        {            // calculate point of next step            Point adj=Point(p.x+directionX[i], p.y+directionY[i]);            if(!isInBound(grid, adj))                continue;            // if point of next step is 0            if(!grid[adj.x][adj.y])            {                //grid[adj.x][adj.y]='0';                q.push(adj);                // change the point immediately after                grid[p.x][p.y]=true;                //step.push(s+1);            }                    }     }        steps++;           }    return -1;}// build post officeconst int WALL=2;const int HOUSE=1;const int EMPTY=0;int n=0;int m=0;/** * @param grid: a 2D grid * @return: An integer */bool inBound(vector<vector<int>> &grid, Point p){    int n=grid.size();    int m=grid[0].size();    return p.x>=0 && p.x<n && p.y>=0 && p.y<m;}void bfs(vector<vector<int>> &grid, Point source, vector<vector<int>> &distance, vector<vector<int>> &visitTime){    vector<vector<int>> localGrid=grid;    int directionX[]={0, 1, -1, 0};    int directionY[]={1, 0, 0, -1};    queue<Point> q;    int depth=0;    q.push(source);    while(!q.empty())    {        int size=q.size();        depth++;                for(int i=0; i<size; i++)        {            Point p=q.front();            q.pop();            for(int i=0; i<4; i++)            {                //cout<<"bfs";                Point adj=Point(p.x+directionX[i], p.y+directionY[i]);                if(!inBound(grid, adj))                    continue;                                if(localGrid[adj.x][adj.y]==EMPTY)                {                    q.push(adj);                    distance[adj.x][adj.y]+=depth; // current total steps                    visitTime[adj.x][adj.y]++;                    localGrid[adj.x][adj.y]=WALL; // already visited                }                                //localGrid[adj.x][adj.y]=1;                // else                //     break;            }                    }                //distance++;    }    }int shortestDistance(vector<vector<int>> &grid) {    // write your code here    //cout<<"first";    if(grid.size()==0 || grid[0].size()==0)        return -1;    n=grid.size();    m=grid[0].size();        vector<vector<int>> distance (n, vector<int> (m, 0));    vector<vector<int>> visitTime (n, vector<int> (m, 0));    vector<Point> empty;    vector<Point> house;    int numHouse=0;    int numEmpty=0;        //cout<<"here";    for(int i=0; i<n; i++)    {        for(int j=0; j<m; j++)        {            // distance[i][j]=0;            // visitTime[i][j]=0;            if(grid[i][j]==HOUSE)                house.push_back(Point(i,j));            if(grid[i][j]==EMPTY)                empty.push_back(Point(i,j));        }    }    //cout<<"count";    numHouse=house.size();    numEmpty=empty.size();    //cout<<numEmpty<<" "<<numHouse;    if(numEmpty==0||numHouse==0)        return -1;    for(auto point : house)    {        bfs(grid, point, distance, visitTime);    }    int minSum=0x7fffffff;    //printMatrix(distance);    for(auto point : empty)    {        if(visitTime[point.x][point.y]==numHouse)            minSum=fmin(minSum, distance[point.x][point.y]);    }        return minSum==0x7fffffff ? -1: minSum;    }//int main(int argc, const char * argv[]) {    // insert code here...    TreeNode n1(2);    TreeNode n2(2);    //n3(5);    //n4(1),n5(3);    //,n6(6),n7(7);    n1.left=NULL;    n1.right=&n2;//    n2.left=&n4;//    n2.right=&n5;    string solution=serialize(&n1);    printf("%s", solution.c_str());    return 0;}