DFS//  Created by SunYutong on 7/27/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <unordered_set>#include <queue>#include <unordered_map>using namespace std;//39. Combination Sum//Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.////The same repeated number may be chosen from candidates unlimited number of times.////Note:////All numbers (including target) will be positive integers.//The solution set must not contain duplicate combinations.vector<int> removeDuplicates(vector<int> &candidates){    sort(candidates.begin(), candidates.end());    int index=0;    for(int i=0; i<candidates.size(); i++)    {        if(candidates[i]!=candidates[index])        {            index++;            candidates[index]=candidates[i];        }    }    return candidates;}void helper(vector<vector<int>> &result, vector<int> &combination, vector<int> & nums, int start, int target){    // 3. exit of recursion    if(target==0){        result.push_back(combination);        return;    }        // 2. recursion step    for(int i=start; i<nums.size(); i++)    {        if(nums[i]>target)            break;        // [1] -> [1,2]        combination.push_back(nums[i]);        // put all combinations starting with [1,2] and has a sum of target into results        helper(result, combination, nums,i, target-nums[i]);        // [1,2] -> [1], backtracking        combination.pop_back();    }}vector<vector<int>> combinationSum(vector<int>& candidates, int target) {    vector<vector<int>> results;    if(candidates.size()==0)        return results;        // remove duplicates    vector<int> num=removeDuplicates(candidates);    vector<int> combination;    helper(results, combination, num, 0, target);        return results;}// 131. Palindrome Partitioning//Given a string s, partition s such that every substring of the partition is a palindrome.////Return all possible palindrome partitioning of s.////Example:////Input: "aab"//Output://[// ["aa","b"],// ["a","a","b"]// ]bool isPalindrome(string s){    for(int i=0, j=s.length()-1; i<=j; i++, j--)    {        if(s[i]!=s[j]){            //cout<<"f ";            return false;        }    }    //cout<<"t ";    return true;}void helper(vector<vector<string>> & results, vector<string> &partition, string s, int start){    if(start==s.length())    {        results.push_back(partition);        //for(auto p : partition)            // cout<<p;            // cout<<" ";            return;    }        for(int i=start; i<s.length(); i++)    {        string subString=s.substr(start, i-start+1);        // cout<<subString;        // cout<<" ";        if(!isPalindrome(subString)){            // cout<<isPalindrome(subString);            // cout<<"\n";            continue;        }        partition.push_back(subString);        helper(results, partition, s, i+1);        partition.pop_back();    }    }vector<vector<string>> partition(string s) {    vector<vector<string>> results;    if(s.length()==0)        return results;        vector<string> partition;    helper(results, partition, s, 0);    return results;}// 46. Permutations// Given a collection of distinct integers, return all possible permutations.//Example:////Input: [1,2,3]//Output://[// [1,2,3],// [1,3,2],// [2,1,3],// [2,3,1],// [3,1,2],// [3,2,1]// ]bool vectorContain(vector<int> & permute, int n){    for(auto p : permute)    {        if(p==n)            return true;    }    return false;}void helperPermute(vector<vector<int>> &results, vector<int> & nums, vector<int> & permute){    int size=nums.size();    if(permute.size()==size)    {        results.push_back(permute);        return;    }    for(int i=0; i<size; i++)    {        if(vectorContain(permute, nums[i]))            continue;        // permute is a vector that stores the permutation with first i+1 numbers selected        permute.push_back(nums[i]);        helperPermute(results, nums, permute);        permute.pop_back();    }}vector<vector<int>> permute(vector<int>& nums) {    vector<vector<int>> results;    vector<int> permute;        if(nums.size()==0){        results.push_back(permute);        return results;    }    helperPermute(results, nums, permute);    return results;    }// 47. Permutations II// Given a collection of numbers that might contain duplicates, return all possible unique permutations.//Example:////Input: [1,1,2]//Output://[// [1,1,2],// [1,2,1],// [2,1,1]// ]void helperPermute2(vector<vector<int>> & results, vector<int>& nums, vector<int>& permute, vector<int> &visited ){    int size=nums.size();    if(permute.size()==size)    {        results.push_back(permute);        return;    }    for(int i=0; i< size; i++)    {        if(visited[i]==1)            continue;        // if we have 2 numbers with same value, eliminate the permutation that we select the 2nd number first and then select the 1st number        // only keep the permutation with selecting 1st number first and then the 2nd number        if(i!=0 && nums[i]==nums[i-1] && visited[i-1]==0){            continue;        }        permute.push_back(nums[i]);        visited[i]=1;        //cout<<visited[i];        helperPermute2(results, nums, permute, visited);        // back tracking, move back and remove previous selection        permute.pop_back();        visited[i]=0;    }}vector<vector<int>> permuteUnique(vector<int>& nums) {    vector<vector<int>> results;    vector<int> permute;        if(nums.size()==0)        return results;    const int n=nums.size();    // visited is an array to keep track of wether we already select ith element nums[i] in permute    // numbers with same value but with different index need to be considered separately when selecting number into permute    vector<int> visited(n,0);    //int visited[n]={0};    sort(nums.begin(), nums.end());    helperPermute2(results, nums, permute, visited);    return results;}// 51. N-Queens// The n-queens puzzle is the problem of placing n queens on an n?n chessboard such that no two queens attack each other.//Given an integer n, return all distinct solutions to the n-queens puzzle.////Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.// my errors & tricky points:// midunderstand the condition that 2 queens attack each other (miss the diagnal situation)// need to (use filled vector to) store the position of all arranged Q, and compute whether Q on board is attacking the current Q// miss considering the situation that n=1// when n<4 and n!=1, should return [], empty vectorstruct Point {    int x;    int y;    Point() : x(0), y(0) {}    Point(int a, int b) : x(a), y(b) {}};bool inBound(vector<string> board, Point p){    int n=board.size();    return p.x>=0 && p.x<n && p.y>=0 && p.y<n;}void helper(vector<vector<string>> &result, vector<string> &board, int n, int numQueen, vector<int> &filled){    // int deltaX[]={1,1,-1,-1};    // int deltaY[]={1,-1,1,-1};    if(numQueen==n)    {        result.push_back(board);        string s;        for(int i=0; i<n; i++)        {            s+=".";        }                vector<string> board(n,s);        return;    }    for(int i=0; i<n; i++)    {                if(filled[i]!=0)            continue;                bool illegal=false;        for(int j=0; j<n;j++)        {            if(numQueen!=0 && filled[j]!=0 && abs(filled[j]-1-numQueen)==abs(j-i))                illegal=true;        }                //             for(int j=0; j<n-1; j++){        //                 //        //                 Point adj=Point(numQueen+j, i+j);        //                 if(inBound(board,adj)){                //                   if(board[adj.x][adj.y]=='Q'){        //                     //cout<<"3";        //                     //cout<<board[numQueen][i];        //                     illegal=true;        //                   }        //             }        //             }        if(illegal)            continue;                        board[numQueen].replace(i,1,"Q");        filled[i]=numQueen+1;                helper(result, board, n, numQueen+1, filled);        board[numQueen].replace(i,1,".");        filled[i]=0;    }}vector<vector<string>> solveNQueens(int n) {    vector<vector<string>> result;    string s={};    for(int i=0; i<n; i++)    {        s+=".";    }        vector<string> board(n,s);    vector<int> filled(n,0);    if(n==1)    {                result.push_back(vector<string>(1,"Q"));        return result;    }    if(n<4)        return result;    helper(result, board, n, 0, filled);        return result;}// 127. Word Ladder//Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:////Only one letter can be changed at a time.//Each transformed word must exist in the word list. Note that beginWord is not a transformed word.//Note:////Return 0 if there is no such transformation sequence.//All words have the same length.//All words contain only lowercase alphabetic characters.//You may assume no duplicates in the word list.//You may assume beginWord and endWord are non-empty and are not the same.// version 1 using BFS:// tricky points:// loop through all the possible letter transformation, and check if 26-1=25 possible next words are contained in unordered_set dict// If the word length is L, the time complexity using hash table to check if a word is in unordered_set is O(L)// BFS:void findNextWord(string &word, unordered_set<string>& dict, queue<string> &q){        int n=word.size();    for(int i=0; i<n; i++)    {        char oldWord=word[i];        for(char c='a'; c<='z'; c++)        {            word[i]=c;            if(c==oldWord)                continue;            if(dict.find(word)!=dict.end())            {                // cout<<"1 ";                // cout<<word;                // if(word==end){                //     cout<<"2";                //     return true;                // }                q.push(word);                dict.erase(word); // already visited            }                    }        word[i]=oldWord;    }    //return false;    }int ladderLength(string beginWord, string endWord, vector<string>& wordList) {    if(beginWord==endWord)        return 1;    int beginSize=beginWord.size();    if(beginSize<1 || beginSize!=endWord.size())        return 0;    // use unordered_set to quickly store and search a word in wordList    // use .find and .end function in unordered_set    unordered_set<string> dict;    int n=wordList.size();    for(int i=0; i<n; i++)    {        dict.insert(wordList[i]);    }        queue<string> q;    q.push(beginWord);    dict.erase(beginWord);    int depth=0;        while(!q.empty())    {        depth++;        int size=q.size();        for(int i=0; i<size; i++)        {            string word=q.front();            q.pop();            if(word==endWord)                return depth;                        findNextWord(word, dict, q);            //                 if(result){            //                     cout<<depth;            //                     return depth;                        //                 }        }    }    return 0;}// version 2, BFS with fewer functions:int ladderLength2(string beginWord, string endWord, vector<string>& wordList) {    if(beginWord==endWord)        return 1;    int beginSize=beginWord.size();    if(beginSize<1 || beginSize!=endWord.size())        return 0;    // use unordered_set to quickly store and search a word in wordList    // use .find and .end function in unordered_set    unordered_set<string> dict;    int n=wordList.size();    for(int i=0; i<n; i++)    {        dict.insert(wordList[i]);    }        queue<string> q;    q.push(beginWord);    dict.erase(beginWord);    int depth=0;        while(!q.empty())    {        depth++;        int size=q.size();        for(int i=0; i<size; i++)        {            string word=q.front();            q.pop();            // if(word==endWord)            //     return depth;            //vector<string> next;            int n=word.size();            for(int j=0; j<n; j++)            {                char oldWord=word[j];                for(char c='a'; c<='z'; c++)                {                    word[j]=c;                    if(c==oldWord)                        continue;                    if(dict.find(word)!=dict.end())                    {                        // cout<<"1 ";                        // cout<<word;                        if(word==endWord){                            //cout<<"2";                            return depth+1;                        }                        q.push(word);                        dict.erase(word); // already visited                    }                                    }                word[j]=oldWord;            }        }    }    return 0;}// 126. Word Ladder II// need to use DFS to find all possible paths// do not use unordered_set to store next nodes, use vectorvoid dfs(vector<vector<string>> & result, vector<string> & path, vector<string>& wordList, string word, string end, unordered_map<string, vector<string>>& next, unordered_map<string, int>& steps){    if(word==end)    {        result.push_back(path);        return;    }    vector<string> nextWord=next[word];        for(auto n : nextWord)    {        if(steps[n]!=steps[word]+1)            continue;        path.push_back(n);        dfs(result, path, wordList, n, end, next, steps);        path.pop_back();    }}vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {    vector<vector<string>> result;    vector<string> path;    unordered_map<string, vector<string>> next;    unordered_map<string, int> steps;    unordered_set<string> dict;    int s=wordList.size();    for(int i=0; i<s; i++)    {        dict.insert(wordList[i]);    }    int depth=1;    queue<string> q;    q.push(beginWord);    steps[beginWord]=depth;    bool exit=false;    while(!q.empty())    {        depth++;        int size=q.size();        for(int i=0; i<size; i++)        {            string current=q.front();            q.pop();            if(current==endWord)            {                exit=true;                break;            }            int l=current.length();            for(int j=0; j<l; j++)            {                string oldWord=current;                char old=oldWord[j];                //cout<<oldWord<<":";                for(char c='a'; c<='z'; c++)                {                    if(c==old)                        continue;                                        current[j]=c;                    bool repeat=false;                    for(auto w: next[oldWord]){                        if(w==current)                            repeat=true;                    }                    if(repeat)                        continue;                                        if(dict.find(current)!=dict.end() && (steps.find(current)==steps.end()||steps[current]==depth))                    {                        q.push(current);                                                next[oldWord].push_back(current);                                    steps[current]=depth;                    }                    current=oldWord;                }            }        }        if(exit)            break;    }    path.push_back(beginWord);    dfs(result, path, wordList, beginWord, endWord, next, steps);    return result;    }// Faster Version:// When doing BFS, add the next word of current word into queue only if the word is not visited before. However, we can add the same word serval times in next vector of different words.void dfs2(vector<vector<string>> & result, vector<string> & path, vector<string>& wordList, string word, string end, unordered_map<string, vector<string>>& next, unordered_map<string, int>& steps){if(word==end){    result.push_back(path);        //cout<<"1";    return;}vector<string> nextWord=next[word];for(auto n : nextWord){    if(steps[n]!=steps[word]+1)        continue;    path.push_back(n);    dfs(result, path, wordList, n, end, next, steps);    //cout<<n<<" ";    path.pop_back();}}vector<vector<string>> findLadders2(string beginWord, string endWord, vector<string>& wordList) {    vector<vector<string>> result;    vector<string> path;    unordered_map<string, vector<string>> next;    unordered_map<string, int> steps;    unordered_set<string> dict;    int s=wordList.size();    for(int i=0; i<s; i++)    {        dict.insert(wordList[i]);    }    int depth=1;    //int n=wordList.size();        queue<string> q;    q.push(beginWord);    steps[beginWord]=depth;    bool exit=false;    while(!q.empty())    {        depth++;        int size=q.size();        for(int i=0; i<size; i++)        {            string current=q.front();            q.pop();            if(current==endWord)            {                exit=true;                                break;            }            //steps[current]=depth;            int l=current.length();            //cout<<current<<":";            for(int j=0; j<l; j++)            {                string oldWord=current;                char old=oldWord[j];                //cout<<oldWord<<":";                for(char c='a'; c<='z'; c++)                {                    if(c==old)                        continue;                                        current[j]=c;                    bool repeat=false;                    for(auto w: next[oldWord]){                        if(w==current)                            repeat=true;                    }                    if(repeat)                        continue;                                        if(dict.find(current)!=dict.end() && (steps.find(current)==steps.end()||steps[current]==depth))                        //if(dict.find(current)!=dict.end() && next[oldWord])                    {                        if(steps.find(current)==steps.end())                            q.push(current);                        //cout<<current;                        next[oldWord].push_back(current);                        // for(auto a:next[oldWord])                        //cout<<a<<" ";                        //cout<<".";                        steps[current]=depth;                    }                    current=oldWord;                }            }            //cout<<",";        }        //cout<<"|";        if(exit)            break;    }    path.push_back(beginWord);    dfs2(result, path, wordList, beginWord, endWord, next, steps);            return result;    }// version 2:// BFS end->start// DFS start->end//int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}