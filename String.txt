String//  Created by SunYutong on 8/2/18.//  Copyright © 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <string>#include <unordered_map>#include <unordered_set>#include <sstream>#include <queue>#include <functional>using namespace std;vector<string> split(const string &str, string delim) {    vector<string> results;    int lastIndex = 0, index;    while ((index = str.find(delim, lastIndex)) != string::npos) {        results.push_back(str.substr(lastIndex, index - lastIndex));        lastIndex = index + delim.length();    }        if (lastIndex != str.length()) {        results.push_back(str.substr(lastIndex, str.length() - lastIndex));    }        return results;}int lengthLongestPath(string input) {    int l=input.length();    int sum[l+1];    int maxLength=0;    vector<string> files;    files=split(input, "\n");    for(auto line : files)    {        int level=line.find_last_of("\t")+2;        int len=line.length()-level+1;        if(line.find('.')!=string::npos)            maxLength=max(maxLength, sum[level-1]+len);        //sum[level]=sum[level-1]+len;        else            sum[level]=sum[level-1]+len+1;    }    return maxLength;}// java version:// this problem is much easier in jave//public int lengthLongestPath(String input) {//    // Write your code here//    if (input.length() == 0) {//        return 0;//    }//    int ans = 0;//    int[] sum = new int[input.length() + 1];////    for (String line : input.split("\n")) {//        int level = line.lastIndexOf('\t') + 2;//        int len = line.length() - (level - 1);//        if (line.contains(".")) {//            ans = Math.max(ans, sum[level - 1] + len);//        } else {//            sum[level] = sum[level - 1] + len + 1;//        }//    }//    return ans;//}// 14. Longest Common Prefixstring longestCommonPrefix(vector<string>& strs) {    int size=strs.size();    if(size==0)        return "";    if(size==1)        return strs[0];    string lastSub;    string sub;    bool prefix=true;    int l=strs[0].length();    for(int i=1; i<=l; i++ )    {        lastSub=sub;        sub=strs[0].substr(0,i);        for(auto n:strs)        {            if(n.substr(0,i)!=sub)                prefix=false;        }        if(!prefix){            //cout<<"not prefix";            break;        }    }    if(!prefix)    {        return lastSub;    }            return sub;}// 819. Most Common Wordstring mostCommonWord(string p, vector<string>& banned) {    unordered_set<string> ban(banned.begin(), banned.end());    unordered_map<string, int> count; // count is a map that sotres the counts for all unique words    // 1.   remove all punctuations    //   NOTE: change to lowercase    for (auto & c: p) c = isalpha(c) ? tolower(c) : ' ';    istringstream iss(p);    string w;    pair<string, int> res ("", 0); // res stores the most common word so far and its count    while (iss >> w) //2. words count for each word not in banned set        if (ban.find(w) == ban.end() && ++count[w] > res.second)            res = make_pair(w, count[w]); // 3. Only update the res pair (with word and its count) if the new count beats the previous max count    // 4. return the most common word    return res.first;}// C++???ostringstream?istringstream?stringstream???????????????????<sstream>??????//istringstream?????C++???????????//ostringstream?????C???????????//strstream???????C?????????????//////istringstream??????????//istringstream::istringstream(string str);//??????string??str??????//////#include<iostream>//#include<sstream>        //istringstream ?????????//#include<string>//using namespace std;//int main()//{//    string str="i an a boy";//    istringstream is(str);//    string s;//    while(is>>s)//    {//        cout<<s<<endl;//    }////}//???://i//am//a//boy// python://def mostCommonWord(self, p, banned)://ban = set(banned)//words = re.findall(r'\w+', p.lower())//return collections.Counter(w for w in words if w not in ban).most_common(1)[0][0]// Heap:// 264. Ugly Number II// Write a program to find the n-th ugly number.//Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.////Example:////Input: n = 10//Output: 12//Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.// Priority queue method:// need to keep track of all numbers in the sequence and avoid repeated numbers// need to use long rather than int// input : 1407// expected output: 536870912int nthUglyNumber(int n) {    priority_queue<long, vector<long>, greater<long>> q;// min heap    unordered_set<long> set;    long prime[3];    prime[0]=2;    prime[1]=3;    prime[2]=5;    long num=1;    // push 2,3,5 into queue    for(int i=0; i<3; i++) {        q.push(prime[i]);        set.insert(prime[i]);    }    // loop n times to pop the front of queue and multiply it by 2 3 and 5    // push the results into the queue if the number is not already in the hash table (unordered_set)    // ERROR: used i<n instead of i<n-1. The loop is last excuted when i=n-2, since we did not push '1' into the priority queue, se we need to find the n-1th ugly number, which is at index n-2    for(int i=0; i<n-1; i++) {        num=q.top();        q.pop();        for(int j=0; j<3; j++) {            if(set.find(num*prime[j])==set.end()) {                q.push(num*prime[j]);                set.insert(num*prime[j]);            }        }    }    return (int)num;    }// jiuzhang solution: method 2int nthUglyNumber2(int n) {    int *uglys = new int[n];    uglys[0] = 1;    int next = 1;    int *p2 = uglys;    int *p3 = uglys;    int *p5 = uglys;    while (next < n){        int m = min(min(*p2 * 2, *p3 * 3), *p5 * 5);        uglys[next] = m;        while (*p2 * 2 <= uglys[next])            *p2++;        while (*p3 * 3 <= uglys[next])            *p3++;        while (*p5 * 5 <= uglys[next])            *p5++;        next++;    }    int uglyNum = uglys[n - 1];    delete[] uglys;    return uglyNum;}// lintcode: Top k Largest Numbers// Given an integer array, find the top k largest numbers in it.// Given [3, 10, 1000, -99, 4, 100] and k =3// Return [1000, 100, 10]// priority queue:// Use min heap to keep the top k numbers. If the number is < the top of the priority queue, it will not be added to the priority queue. If the number is > the top, check all logk levels to see which level the number should be at.bool cmp(const int& a, const int& b) {    return a>b;}class Solution {private:    priority_queue<int, vector<int>, greater<int>> minheap;// min heap    int k;public:    Solution(int k) {        this->k = k;    }void add(int n) {    if(minheap.size()<k)        minheap.push(n);    else if(n>minheap.top()) {        minheap.pop();        minheap.push(n);    }}vector<int> topk(vector<int> &nums, int k) {    priority_queue<int, vector<int>, greater<int>> minheap;// min heap    vector<int> result;    for(auto n:nums) {        if(minheap.size()<k)            minheap.push(n);        else if(n>minheap.top()) {                minheap.pop();                minheap.push(n);        }    }    for(int i=0; i<k; i++){        result[i]=minheap.top();        minheap.pop();    }    sort(result.begin(), result.end(), cmp);    return result;}};// 347. Top K Frequent Elements (hard)//Given a non-empty array of integers, return the k most frequent elements.////For example,//Given [1,1,1,2,2,3] and k = 2, return [1,2].////Note://You may assume k is always valid, 1 ² k ² number of unique elements.//Your algorithm's time complexity must be better than O(n log n), where n is the array's size.// 23. Merge k Sorted Lists// Method 1: Divide & Conquer (beats 99.7%) // Definition for singly-linked list.struct ListNode {    int val;     ListNode *next;     ListNode(int x) : val(x), next(NULL) {} };    // function to merge 2 lists, similar to function in merge sort    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {        ListNode* dummy=new ListNode(0);        ListNode* tail=dummy;        while(list1!=NULL && list2!=NULL) {            if(list1->val < list2->val) { // if list1 is smaller, add node pointed by list1 to tail of the merged list, and move list1 back by 1                tail->next=list1;                tail=list1;                list1=list1->next;            } else { // move list2 back by 1                tail->next=list2;                tail=list2;                list2=list2->next;            }        }        if(list1!=NULL) // if list1 has nodes left            tail->next=list1;        if(list2!=NULL)            tail->next=list2;        return dummy->next;    }        // start is the first index of lists that we want to sort, and end is the last index of lists that we want to sort in this function// divide & conquer    ListNode* mergeHelper(vector<ListNode*>& lists, int start, int end) {        if(start==end)            return lists[start];        int mid=start+(end-start)/2;        ListNode* left=mergeHelper(lists, start, mid);        ListNode* right=mergeHelper(lists, mid+1, end);        return mergeTwoLists(left,right);    }        ListNode* mergeKLists(vector<ListNode*>& lists) {        // 1. eliminate the condition when lists is empty        if(lists.size()==0)            return NULL;        // 2. use helper function recursively, and divide merging k lists into merging 2 lists        return mergeHelper(lists, 0, lists.size()-1);    }// Heap method (easier to implement): (beats 99.7%) **********************struct compare{    bool operator()(ListNode* a, ListNode* b) {        return a->val > b->val;    }};ListNode* mergeKLists2(vector<ListNode*>& lists) {    if(lists.size()==0)        return NULL;    priority_queue<ListNode*, vector<ListNode*>,compare > heap; // min heap, top of heap is min    // 1. add the first node of k lists into heap    for(int i=0; i<lists.size(); i++) {        // don't push NULL pointer in the heap        if(lists[i]!=NULL)            heap.push(lists[i]);    }    // 2. build the new merged list with a dummy node    ListNode* dummy=new ListNode(0);    ListNode* tail=dummy;    // 3. pop a node out of the heap and add it to the end of the list, add the next node of it to the heap until the end of the list. Exit when all nodes are popped.    while (!heap.empty()) {        ListNode* temp=heap.top();        heap.pop();        tail->next=temp;        tail=tail->next; // move tail to the next node        // if the node temp points to is not the end of the list, push the pointer to the next node into heap        if(temp->next!=NULL)            heap.push(temp->next);    }    // NOTE: Not like divide & concuqer method, we don't need to consider the situation that one of the lists is remaining outside the heap, as long as there is a not NULL pointer left, it will be added to the heap and be popped in sorted order.    // 4. return the next node of dummy node    return dummy->next;}int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}