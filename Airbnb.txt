Airbnb////  Created by SunYutong on 9/5/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <string>#include <unordered_map>#include <queue>using namespace std;// 755. Pour Water// Array:vector<int> pourWater(vector<int>& heights, int V, int K) {    int size=heights.size();    for(int i=0; i<V; ++i) {        ++heights[K];        int oldHeight=heights[K];        int left=K-1, curr=K;        while(left>=0) {            if(heights[left]>heights[curr]-1) break;            else if (heights[left]!=heights[curr]-1)            {                --heights[curr];                ++heights[left];                curr=left;            }            --left;        }        if(oldHeight!=heights[K]) continue;        int right=K+1;        curr=K;        while(right<size) {            if(heights[right]>heights[curr]-1) break;            else if (heights[right]!=heights[curr]-1)            {                --heights[curr];                ++heights[right];                curr=right;            }            ++right;        }    }    return heights;}// 336. Palindrome Pairs (hard)// Hash table, Trie://    Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.////    Example 1://    Input: ["abcd","dcba","lls","s","sssll"]//    Output: [[0,1],[1,0],[3,2],[2,4]]//    Explanation: The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]//    Example 2://    Input: ["bat","tab","cat"]//    Output: [[0,1],[1,0]]//    Explanation: The palindromes are ["battab","tabbat"]// IDEA: Hash table method:// Traverse the array, build map. Key is the reversed string, value is index in array (0 based)//// Edge case - check if empty string exists. It's interesting that for given words {"a", ""}, it's expected to return two results [0,1] and [1,0]. Since my main logic can cover [0, 1] concatenate("a", ""), so as to cover the other situation concatenate("", "a"), I need to traverse the words array again, find the palindrome word candidate except "" itself, and add pair("", palindrome word) to the final answer.//// Main logic part. Partition the word into left and right, and see 1) if there exists a candidate in map equals the left side of current word, and right side of current word is palindrome, so concatenate(current word, candidate) forms a pair: left | right | candidate. 2) same for checking the right side of current word: candidate | left | right.// My hash table method using idea above: beats 84%// Function to check if the substring of s from element at index start to element at index end is a palindrome.bool isPalindrome(string s, int start, int end) {    while(start<end) {        if(s[start]!=s[end]) return false;        // NOTE: remember to move the pointer, this is a while loop!!!        ++start;        --end;    }    return true;}vector<vector<int>> palindromePairs(vector<string>& words) {    vector<vector<int>> result;    unordered_map<string, int> map;    bool hasEmpty=false;    int emptyPos;    // 1. Put all strings in words to the hash table with their index.    int size=words.size();    for(int i=0; i<size; ++i) {        if(words[i]=="") {            hasEmpty=true;            emptyPos=i;            continue;        }        map[words[i]]=i;    }       for(int i=0; i<size; ++i) {        string candidate=words[i];        string w=words[i];        int l=w.size();            if(l>1)            reverse(candidate.begin(),candidate.end());                vector<int> pair(2,0);    // 2. Use the elements in words as left part of palindrome, search for candidate of right part in hash table. The palindrome contains left | right | candidate (right is a palindrome). If candidate found, push the index pair into result vector.        // (1) start is the last index of left. start + 1 is the first index of right. Move start to the left recursively to find all right that is a palindrome.        int start=l-1;        while(start>=0) {            // (2) check if from start + 1 to the end of word w is a palindrome            if(isPalindrome(w, start+1, l-1))            {                // (3) If we find a mapping of candidate (candidate.substr(l-start-1) where candidate is the reversed string of w), build a vector with i and the index candidate maps to, and push it to result vecotr.                // ***Skip the case if when candidate is the same as word w.                if(map.count(candidate.substr(l-start-1)) && map[candidate.substr(l-start-1)]!=i) {                    pair[0]=i;                    pair[1]=map[candidate.substr(l-start-1)];                    result.push_back(pair);                }            }            --start;        }    // 3. Use the elements in words as right part of palindrome, search for candidate of left part in hash table. The palindrome contains candidate | left | right (left is a palindrome). If candidate found, push the index pair into result vector.        int end=1; // IMPORTANT: Skip end=0, since when end == 0, the left candidate is the same as the right candidate when start == l-1.        // (1) end is the first index of right, and end - 1 is the last index of left. Move end pointer to the right recursively.        while(end<l) {            // (2) check if from index 0 to the end - 1 of word w is a palindrome            if(isPalindrome(w, 0, end-1))            {                // (3) search candidate in map, if found, push index pair into result vecotr.                // Skip the case if when candidate is the same as word w.                if(map.count(candidate.substr(0, l-end)) && map[candidate.substr(0,l-end)]!=i) {                    pair[0]=map[candidate.substr(0,l-end)];                    pair[1]=i;                    result.push_back(pair);                }            }            ++end;        }        // 4. Add in the pairs with 1 empty string in if we have found "" when we build the map. Skip the case if        if(hasEmpty && i!=emptyPos && isPalindrome(w, 0, l-1)) {            pair[1]=emptyPos,pair[0]=i;            result.push_back(pair);            if(w=="") continue;            pair[0]=emptyPos,pair[1]=i;            result.push_back(pair);        }    }    return result;}// 751. IP to CIDR// Bit manipulation://    Given a start IP address ip and a number of ips we need to cover n, return a representation of the range as a list (of smallest possible length) of CIDR blocks.////    A CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length. For example: "123.45.67.89/20". That prefix length "20" represents the number of common prefix bits in the specified range.////    Example 1://    Input: ip = "255.0.0.7", n = 10//    Output: ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]int GetTrailingZero(int ip){    if (ip == 0) return sizeof(int);    int count = 0;    while ((ip & 0x1) == 0)    {        count ++;        ip >>= 1;    }        return count;}vector<string> ipToCIDR(string ip, int n) {    long start = 0;    vector<int> num(4,0);    std::stringstream s(ip);    char c;    s>>num[0]>>c>>num[1]>>c>>num[2]>>c>>num[3];    for(auto a : num) start = start * 256 + a;        vector<string> ans;    while(n>0){        int trailingZeros = GetTrailingZero(start);        int covered = 1 << trailingZeros;        while (covered > n)        {            covered >>= 1;            trailingZeros --;        }                        char buf[200];        sprintf(buf, "%d.%d.%d.%d/%d", (start >> 24) & 0xFF, (start >> 16) & 0xFF,                (start >> 8) & 0xFF, start & 0xFF, 32 - trailingZeros);        ans.emplace_back(buf);        n -= covered;        start += covered;    }    return ans;}// 251. Flatten 2D Vector// Design, iterator://    Implement an iterator to flatten a 2d vector.////    Example://    Input: 2d vector =//    [//     [1,2],//     [3],//     [4,5,6]//     ]//    Output: [1,2,3,4,5,6]//    Explanation: By calling next repeatedly until hasNext returns false,//    the order of elements returned by next should be: [1,2,3,4,5,6].//    Follow up://    As an added challenge, try to code it using only iterators in C++ or iterators in Java.// Queue solution: (easy)class Vector2D {public:    queue<int> q;    Vector2D(vector<vector<int>>& vec2d) {        int size=vec2d.size();        for(int i=0; i<size; ++i) {            int s=vec2d[i].size();            for(int j=0; j<s; ++j)                q.push(vec2d[i][j]);        }    }    int next() {        int next=q.front();        q.pop();        return next;    }        bool hasNext() {        return !q.empty();    }};/** * Your Vector2D object will be instantiated and called as such: * Vector2D i(vec2d); * while (i.hasNext()) cout << i.next(); */// Required in the followup!!!// iterator operation solution:// Just keep two iterators for first level (each row) and second level (each int in a row). For each next(), move the iterator forward until we find a none-null position.class Vector2D2 {public:    // Helper function: check if row iterator is at the end of a row, if so move row to the begin of itrs, and move itrs to the next row.    void getNextRow(){        // If row iterator is at the end of a row,        while (itrs != end && row == itrs->end()) {            // - move itrs to the next row            itrs++;            // - if it is not the last row, move row to the begin of itrs            if (itrs != end) row = itrs->begin();        }    }        Vector2D2(vector<vector<int>>& vec2d) {        // 1. Set the itrs (iterator for each row) to the begin iterator of the 2d vector.        // Record the end iterator as the end of 2d vector.        // Set the row iterator (for each int in a row) to the begin iterator of the vector that itrs points to, which is the first row.        itrs = vec2d.begin(); // ***current row        end = vec2d.end(); // ***end row        // NOTE: Use this condition to avoid following NULL pointer when itrs is at end.        if (itrs != end)            row = itrs->begin(); // ***each element in a row        // 2. Use getNextRow() to deal with the condition that the first row (or first few rows) only has 1 int in it.        getNextRow(); // IMPORTANT!!!    }        int next() {        // 1. Get the current int, the int val that row points to, and move row to point to the next element. (if it is the last element in a row, row will points to .end() after this step).        int next = *row;        row++;        // 2. Deal with the condition that row is at the end of a row. (row == itrs->end())        getNextRow(); // in case row is at the end of a row.        return next;    }        bool hasNext() {        // Only need to check if the current row is at the next index after the last row of vec2d (end).        return itrs != end;    }private:    vector<vector<int>>::iterator itrs, end; // iterator for iterating through one row at a time.    vector<int>::iterator row; // iterator to loop through all int in each row.};/** * Your Vector2D object will be instantiated and called as such: * Vector2D i(vec2d); * while (i.hasNext()) cout << i.next(); */// 787. Cheapest Flights Within K Stops// DP://    There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.////    Now given all the cities and fights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}