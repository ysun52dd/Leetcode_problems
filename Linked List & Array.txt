Linked List & Array////  Created by SunYutong on 7/30/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <cmath>#include <unordered_map>using namespace std;// 25. Reverse Nodes in k-Group// use of dummy node:// When do we need to use dummy node?// if the returned head node will be changed.// use dummy->next to point to the 1st node of returned liststruct ListNode {        int val;        ListNode *next;        ListNode(int x) : val(x), next(NULL) {}    };ListNode* reverseNextK(ListNode* head, int k){        // n1 is pointing to node 1    ListNode* n1=head->next;    if(n1==NULL)        return NULL;    // head is pointing to dummy node    ListNode* nk=head;    // point head to node k        for(int i=0; i<k; i++){        nk=nk->next;        if(nk==NULL)            return NULL;    }    // reverse node 1 to node k 2 nodes at a time    ListNode* nextHead=nk->next;    ListNode* prev=NULL;    ListNode* cur=n1;    ListNode* temp;    while(cur!=nextHead){        // ********* reverse liked list method *****************        temp=cur->next;        cur->next=prev;        prev=cur;        cur=temp;         // *************************************************    }    // connect node 1 and node k    head->next=nk;    n1->next=nextHead;    // n1 is the previous node of the 1st node of the next k nodes    return n1;}ListNode* reverseKGroup(ListNode* head, int k) {    // *********************** use of dummy node ***********************    ListNode* dummy=new ListNode(0);    dummy->next=head;    // *********************** use of dummy node ***********************    head=dummy;    while(head!=NULL)    {        head=reverseNextK(head, k);    }    // *********************** use of dummy node ***********************    return dummy->next;}// 138. Copy List with Random Pointer// Hot Problem, need to remember!!!// Tricky method: save space (only use O(1) extra space other than input and output) compared to the method using map to map all old nodes to new nodes// make a copy of each node and insert the new node after the original node.// head->1->1'->2->2'->...->n'->NULL, head is always pointing to the original node.// then copy all the random pointer of each node using head->next->random=head->random->next.// Finally, split the list into the original list and the copied list.struct RandomListNode {    int label;    RandomListNode *next, *random;    RandomListNode(int x) : label(x), next(NULL), random(NULL) {}};void copyNext(RandomListNode *head){    while(head!=NULL)    {        RandomListNode *newNode=new RandomListNode(head->label);                //newNode->random=head->random;        newNode->next=head->next;        head->next=newNode;        // head->1->1'->2->...        // move head pointer to point to 2        head=head->next->next;    }}void copyRandom(RandomListNode* head){    while(head!=NULL){        if(head->random!=NULL)            head->next->random=head->random->next;        // move to the next pair        head=head->next->next;    }}// *********** had problem: ************// did not use temp pointer to point to 1'// need to deal with 1->2 and 1'->2' in one loopRandomListNode *splitList(RandomListNode *head){    // head->1->1'->2->2'->...->n'->null    //   newHead->1'->2->2'    RandomListNode *newHead=head->next;    while(head!=NULL)    {        // temp is pointing to 1'        RandomListNode *temp=head->next;                // 1->2        head->next=temp->next;        head=head->next;        // 1'->2'        if(temp->next!=NULL)            temp->next=temp->next->next;            }    return newHead;}RandomListNode *copyRandomList(RandomListNode *head) {    if(head==NULL)        return NULL;    RandomListNode *newHead;    copyNext(head);    copyRandom(head);    newHead=splitList(head);    return newHead;}// 141. Linked List Cycle// 148. Sort List// merge sort using linked listListNode* findMiddle(ListNode* head){    ListNode* slow=head;    // need to set fast to head->next!!!???    ListNode* fast=head->next;    // If fast pointer is not out of bound, don't need to consider slow pointer    // fast pointer goes 2 times faster than slow pointer    // When fast pointer is just out of bound, the slow pointer is pointing to the middle    while(fast!=NULL && fast->next!=NULL)    {        fast=fast->next->next;        slow=slow->next;    }    return slow;}ListNode* merge(ListNode* list1, ListNode* list2) {    if(list1==NULL) return list2;    if(list2==NULL) return list1;    ListNode* dummy=new ListNode(0);        ListNode* temp=dummy;        while(list1!=NULL && list2!=NULL){        if(list1->val<list2->val){            temp->next=list1;            list1=list1->next;        }        else {            temp->next=list2;            list2=list2->next;        }        // very important!!! temp is always pointing to the last merged node at the begining of this loop        temp=temp->next;    }        if(list1!=NULL)        temp->next=list1;    if(list2!=NULL)        temp->next=list2;        return dummy->next;    }ListNode* sortList(ListNode* head) {    if(head==NULL || head->next==NULL)        return head;    //ListNode* list1;    ListNode* middle=findMiddle(head);    ListNode* list2=sortList(middle->next);    // cut the list into 2 parts    middle->next=NULL;    ListNode* list1=sortList(head);    return merge(list1, list2);    }// version 2: quick sort// In java://public class Solution {//    public ListNode sortList(ListNode head) {//        if (head == null || head.next == null) {//            return head;//        }////        ListNode mid = findMedian(head); // O(n)////        ListNode leftDummy = new ListNode(0), leftTail = leftDummy;//        ListNode rightDummy = new ListNode(0), rightTail = rightDummy;//        ListNode middleDummy = new ListNode(0), middleTail = middleDummy;//        while (head != null) {//            if (head.val < mid.val) {//                leftTail.next = head;//                leftTail = head;//            } else if (head.val > mid.val) {//                rightTail.next = head;//                rightTail = head;//            } else {//                middleTail.next = head;//                middleTail = head;//            }//            head = head.next;//        }////        leftTail.next = null;//        middleTail.next = null;//        rightTail.next = null;////        ListNode left = sortList(leftDummy.next);//        ListNode right = sortList(rightDummy.next);////        return concat(left, middleDummy.next, right);//    }////    private ListNode findMedian(ListNode head) {//        ListNode slow = head, fast = head.next;//        while (fast != null && fast.next != null) {//            slow = slow.next;//            fast = fast.next.next;//        }//        return slow;//    }////    private ListNode concat(ListNode left, ListNode middle, ListNode right) {//        ListNode dummy = new ListNode(0), tail = dummy;////        tail.next = left; tail = getTail(tail);//        tail.next = middle; tail = getTail(tail);//        tail.next = right; tail = getTail(tail);//        return dummy.next;//    }////    private ListNode getTail(ListNode head) {//        if (head == null) {//            return null;//        }////        while (head.next != null) {//            head = head.next;//        }//        return head;//    }//}// 53. Maximum Subarrayint maxSubArray(vector<int>& nums) {    int size=nums.size();    int prefixSum=nums[0];    int sumMax=nums[0];    int prefixSumMin=0;    //int sum[size];    for(int i=1; i<size; i++)    {        // min within all prefix sum before index i (0~i-1)        prefixSumMin=fmin(prefixSumMin, prefixSum);        // recalculate prefixSum by adding nums[i]        prefixSum+=nums[i];        sumMax=fmax(sumMax, prefixSum-prefixSumMin);    }    return sumMax;}// 2. Add Two Numbers//You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.////You may assume the two numbers do not contain any leading zero, except the number 0 itself.////Example:////Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)//Output: 7 -> 0 -> 8//Explanation: 342 + 465 = 807.ListNode* addTwoNumbers(ListNode* l1, ListNode* l2){    ListNode* dummyHead = new ListNode(0);    ListNode* p = l1;    ListNode* q = l2;    ListNode* curr = dummyHead;    int x,y=0;    int carry = 0;    while (p != nullptr || q != nullptr) {        if(p==nullptr)            x =0;        else            x=p->val;        if(q==nullptr)            y=0;        else            y=q->val;        int sum = carry + x + y;        carry = sum / 10;        curr->next = new ListNode(0);        curr->next->val=sum%10;        curr = curr->next;        if (p != nullptr) p = p->next;        if (q != nullptr) q = q->next;    }    if (carry > 0) {        curr->next = new ListNode(carry);    }    return dummyHead->next;}// Array:// 621. Task Schedulerint leastInterval(vector<char>& tasks, int n) {    int maxCount=0;    // store the count of each task in a map    unordered_map<char, int> map;    for(auto n: tasks)    {        map[n]++;        // calculate the max count of all tasks        maxCount=fmax(maxCount, map[n]);    }    // first arrange the first maxCount-1 tasks, each 2 tasks has n tasks in between,    // therefore, including the task with maxCount, there are (maxCount-1)*(n+1) tasks    int intervals=(maxCount-1)*(n+1);    //  find out how many tasks need to be add at the end    for(auto m:map)    {        // only consider the tasks with a count of maxCount        if(m.second==maxCount)            intervals++;    }    // if number of size is larger than intervals, there are more than n tasks in between 2 same tasks.    intervals=fmax(tasks.size(), intervals);    return intervals;}// Merge Sorted Array//Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.////Note:////The number of elements initialized in nums1 and nums2 are m and n respectively.//You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.//Example:////Input://nums1 = [1,2,3,0,0,0], m = 3//nums2 = [2,5,6],       n = 3////Output: [1,2,2,3,5,6]void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {    while(n>0)    {        if(nums1[m-1]>nums2[n-1] && m!=0)        {            nums1[m+n-1]=nums1[m-1];            cout<<m<<" "<<nums1[m+n-1]<<" ";            m--;        }        else        {            nums1[m+n-1]=nums2[n-1];            cout<<n<<" "<<nums1[m+n-1]<<" ";            n--;        }    }}// 349. Intersection of Two Arrays//Given two arrays, write a function to compute their intersection.////Example://Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].////Note://Each element in the result must be unique.//The result can be in any order.vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {    unordered_map<int, int> map;    vector<int> result;    for(auto n:nums1)    {        map[n]=1;    }    for(auto m:nums2)    {        if(map[m]==1)            result.push_back(m);        map[m]=0;    }    return result;}// kth largest// wrong answer:int findKthLargest(vector<int>& nums, int k) {if(nums.size()==1 ){    return nums[0];}int n=nums.size();int mid=n/2;vector<int> left;vector<int> right;int result;int pivot=nums[mid];cout<<"pivot is "<<pivot<<endl;for(int i=0;i<n; i++){        if(nums[i]>=pivot){        right.push_back(nums[i]);        //nums.erase(nums.begin()+i);    }    if(nums[i]<pivot)        left.push_back(nums[i]);    }int size =0;if(!right.empty())size=right.size();cout<<"size of right is "<<size<<"\n";if(size==k-1)return pivot;if(size<k){    cout<<"left ";    result=findKthLargest(left, k-size-1);}if(size>k){    cout<<"right ";    result=findKthLargest(right, k-1);}return result;}// quick select:// ******************* need to remember!!! ************************int quickSelect(vector<int>& nums, int left, int right, int k){    int pivot=nums[left];    int i=left;    int j=right;    int temp;    while(i<=j)    {       // find the element that is not suppose to be on the left        while(i<=j && nums[i] > pivot)            i++;        // find the element that is not suppose to be on the right        while(i<=j && nums[j] < pivot)            j--;        if(i<=j)        {            temp=nums[i];            nums[i]=nums[j];            nums[j]=temp;            i++;            j--;        }            }    // cout<<"j:"<<j<<"\n";    // cout<<"i:"<<i<<"\n";    // cout<<"left+k:"<<left+k<<"\n";    //left(larger than pivot)    if(left+k <= j+1)        return quickSelect(nums, left, j, k);    //right    if(left+k >= i+1)        return quickSelect(nums, i, right, k-(i-left));        return nums[j+1];}int findKthLargest2(vector<int>& nums, int k) {    return quickSelect(nums,0,nums.size()-1,k);}// python version://def kthLargestElement(self, k, A)://n = len(A)//k -= 1////def partitionHelper(s, e)://p, q = s + 1, e//while p <= q://if (A[p]>A[s])://p += 1//else://A[p], A[q] = A[q], A[p]//q -= 1////A[s], A[q] = A[q], A[s]////m = q//if m == k://return A[m]//elif m < k://return partitionHelper(m + 1, e)//else://return partitionHelper(s, m - 1)////return partitionHelper(0, n-1)// 4. Median of Two Sorted Arraysdouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {    int m(int(nums1.size())), n(int(nums2.size()));    double med;    int iMin=0;    int iMax=min(m,n);    int i=(iMax+iMin)/2;    int j;    if(m==0&&n==1)        return nums2[0];    if(n==0&&m==1)        return nums1[0];    while(iMax>=iMin)    {        i=((iMax+iMin)+1)/2;                j= (m + n + 1)/2-i;                int L1(0),L2(0),R1(0),R2(0);        if(n>m)        {            if(j-1>=0)                L2=nums2[j-1];            R2=nums2[j];            if(i-1>=0)                L1=nums1[i-1];            if(m!=0&&i<m)                R1=nums1[i];            if(i==m)                R1=R2;        }        else{            if(j-1>=0)                L2=nums1[j-1];                        R2=nums1[j];            if(i-1>=0)                L1=nums2[i-1];            if(n!=0&&i<n)                R1=nums2[i];            if(i==n)                R1=R2;        }        if(R2>=L1&&R1>=L2)        {            if((m+n+2)%2==0)            {                if(R1==0||R2==0)                    med=(max(L1,L2)+max(R1,R2))/double(2);                else                    med=(max(L1,L2)+min(R1,R2))/double(2);            }            else            {                med=max(L1,L2);            }            break;        }        if(R2<L1)            iMax=i-1;        if(R1<L2)            iMin=i+1;    }    return med;}// version 2: find kth smallest number of 2 sorted arrays// index1 & index2 are starting index of array nums1 and nums2// k is the kth smallest number that we want to find among 2 arraysint findKth(vector<int>& nums1, int index1, vector<int>& nums2, int index2, int k){    cout<<"k:"<<k<<"\n";    // nums1 is empty, the starting index of array 1 is out of bound    if(nums1.size()<=index1)        return nums2[index2+k-1];    // nums2 is empty, the starting index of array 2 is out of bound    if(nums2.size()<=index2)        return nums1[index1+k-1];    if(k==1){        int result=fmin(nums1[index1],nums2[index2]);        cout<<"result"<<result<<"\n";        return result;    }    // if key1 or key2 is not modified (position index+k/2 is out of bound)    // key1 or key2 (is infinite) can be larger than the other one, and first k/2 part of the other array will be dropped    int key1=0x7fffffff;    int key2=0x7fffffff;    // access the value of k/2 th element in the current arrary 1 and array 2, and store the value in key1 and key2    if(index1+k/2-1<nums1.size())        key1=nums1[index1+k/2-1];    if(index2+k/2-1<nums2.size())        key2=nums2[index2+k/2-1];       if(key1<key2)        return findKth(nums1, index1+k/2, nums2, index2, k-k/2); //drop the left side of array 1 (to the left of key1)    else        return findKth(nums1, index1, nums2, index2+k/2, k-k/2);//drop the left side of array 2 (to the left of key2)    }double findMedianSortedArrays2(vector<int>& nums1, vector<int>& nums2) {    // size is the total number of elements in 2 sorted arrarys    int size=nums1.size()+nums2.size();    // if nums1 and nums2 are both empty, return 0    if(size==0)        return 0.0;    if(size==1 && nums1.size()==1){        return nums1[0];    }    if(size==1 && nums2.size()==1){        return nums2[0];    }    if(size%2==0){ // If there are even number of elements in 2 arrays, need to find the average of the total size/2th and total size/2 + 1th element.        int n1=findKth(nums1, 0, nums2, 0, size/2);        int n2=findKth(nums1, 0, nums2, 0, size/2+1);        return (n1+n2)/2.0;    }    else // if odd number of element, return the total size/2+1 th element.        return findKth(nums1, 0, nums2, 0, size/2+1);}int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}