Microsoft//  Created by SunYutong on 8/20/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <math.h>#include <queue>#include <stack>using namespace std;// 204. Count Primes  ??? what is the fastest method?// Math, hash table (only use array as a hash table in this case)// Count the number of prime numbers less than a non-negative number, n.// Example:// Input: 10// Output: 4// Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.// method 1: hash table (array)int countPrimes(int n) {    if(n<3) return 0;    int notPrime[n]={0}; // can't use unordered_set, memory limit exceeded!!!    int count=0;    for(int i=2; i<n; ++i) {        if(!notPrime[i]) {            ++count;            for(int j=1; i*j<n; ++j)                notPrime[i*j]=1;        }    }    return count;}// mothod 2: (can't pass, too slow)// ????????bool isPrime(int n, vector<int>& primes) {    for (auto& prime : primes) {        if (prime > sqrt(n)) return true;        if (n % prime == 0) return false;    }    return true;}int countPrimes2(int n) {    if (n < 3) return 0;    vector<int> primes = {2, 3};    for (int i = 4; i != n; ++i) {        if (!isPrime(i, primes)) continue;        primes.push_back(i);    }    return primes.size();}// 402. Remove K Digits// Greedy: deque / stack// Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.// Input: num = "1432219", k = 3// Output: "1219"// Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.string removeKdigits(string num, int k) {    int l=num.length();    if(l<=k) return "0";    deque<char> q;    string result="";    for(int i=0; i<l; ++i) {        while(!q.empty() && num[i]-'0'<q.back()-'0' && k>0) {            q.pop_back();            --k;        }        q.push_back(num[i]);    }    while(k>0) {        q.pop_back();        --k;    }    int left = num.length() - k;    while(!q.empty()) {        result+=q.front();        q.pop_front();    }    result=result.substr(0,left);    int i=0;    while(result[i]=='0') {        ++i;    }    return i==result.length()? "0" : result.substr(i, result.length()-i);}// jiuzhang solution:string removeKdigits2(string &num, int k) {    // write your code here    string res;    if(num.length() == 0) {        return res;    }    stack<char> Stack;    Stack.push(num[0]);    for(int i = 1; i < num.length(); ++i) {        while(!Stack.empty() && Stack.top()- '0' > num[i]- '0' && k > 0) {            k--;            Stack.pop();        }        Stack.push(num[i]);    }    int left = num.length() - k;    while(!Stack.empty()) {        res = Stack.top() + res;        Stack.pop();    }    res = res.substr(0, left); //??????????????????????    int index = 0;    while(res[index] == '0' && (index < res.length() - 1)) { //????0000??0??????0        index++;    }    return res.substr(index, res.length()-index);}// 206. Reverse Linked List// Linked list// Input: 1->2->3->4->5->NULL// Output: 5->4->3->2->1->NULL// Iteratively:struct ListNode {    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) {}};ListNode* reverseList(ListNode* head) {    if(head==NULL || head->next==NULL) return head;    ListNode* curr=head->next;    ListNode* prev=head;    head->next=NULL;    while(curr!=NULL) {        ListNode* temp=curr->next;        curr->next=prev;        prev=curr;        curr=temp;    }    return prev;}// Recursively:ListNode* tail;void reverseHelper(ListNode* prev, ListNode* curr) {    if(curr==NULL) {        tail=prev;        return ;    }    reverseHelper(prev->next,curr->next);    curr->next=prev;}ListNode* reverseList2(ListNode* head) {    if(head==NULL || head->next==NULL) return head;    ListNode* curr=head->next;    ListNode* prev=head;    reverseHelper(prev, curr);    head->next=NULL;    return tail;}// 229. Majority Element II// Array:// Given an integer array of size n, find all elements that appear more than ? n/3 ? times.// Note: The algorithm should run in linear time and in O(1) space.// Input: [3,2,3]// Output: [3]vector<int> majorityElement(vector<int>& nums) {    vector<int> result;    int size=nums.size();    if(size<2) return nums; // NOTE: should not be if(size<3), need to consider the condition that 2 elements in nums are the same and we only need to return that number 1 time. For example, [2,2].    // 1. Use m1 and m2 to keep the 2 candidates of majority element, c1 is the count of m1, c2 is the count of m2. Initialize m1 to nums[0], m2 to nums[1].    int m1=nums[0],m2=nums[1];    int c1=0, c2=0;    // 2. Loop through the vector nums:    // if we meet a candidate, increment its counter.    // if we meet a number that is neither m1 nor m2, decrement c1 and c2.    // if the current number is neither m1 nor m2 and the counter c1 or c2 is 0, replace m1 with current number if c1 == 0, replace m2 with current number if c2 == 0.    for(auto n : nums) {        if(n==m1) ++c1;        else if(n==m2) ++c2;        else if(c1==0) {            m1=n;            c1=1;        }        else if(c2==0) {            m2=n;            c2=1;        }        else {            --c1;            --c2;        }    }    // 3. Loop again from the start of vector nums, count the total number of appearance of 2 candidates, m1 and m2. If the counts of them exceed size/3, push them into result vector, stop pushing m2 if m2 == m1.    c1=0; c2=0;    for(auto n:nums) {        if(n==m1) ++c1;        else if(n==m2) ++c2;    }    if(c1>size/3)        result.push_back(m1);    if(c2>size/3 && m2!=m1)        result.push_back(m2);    return result;}// 277. Find the Celebrity// Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.// Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).// You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.int findCelebrity(int n) {    if(n<2) return -1;    int famous=0;    for(int i=1; i<n; ++i) {        if(knows(i, famous)) continue;        else famous=i;    }    for(int i=0; i<n; ++i) {        if(i==famous) continue;        if(!knows(i,famous)) return -1;        if(knows(famous,i)) return -1;    }    return famous;}// 21. Merge Two Sorted Lists// Linked list:// Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.// Input: 1->2->4, 1->3->4// Output: 1->1->2->3->4->4// NOTE: don't use helper functions if we don't have to do so. Program without this extra function will be much faster!!!void moveNodeToNewList(ListNode* &n1, ListNode* &n2, ListNode* &tail) {    if(n1->val<=n2->val) {        ListNode* temp=n1->next;        tail->next=n1;        //n1->next=NULL;        tail=n1;        n1=temp;    }else {        ListNode* temp=n2->next;        tail->next=n2;        //n1->next=NULL;        tail=n2;        n2=temp;    }}ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {    ListNode* dummy=new ListNode(0);    ListNode* head=dummy;    // 1. Add the smaller head nodes of list 1 or list 2 to the end of the new list. Exit if l1 or l2 is NULL.    while(l1!=NULL && l2!=NULL) {        // The following code in this loop is the same as code in moveNodeToNewList function.        if(l1->val<=l2->val) {            // NOTE: don't need to use this conditional statement, it will kill speed!!!            // if(head->next==l1) {            //     head=head->next; l1=l1->next;            //     continue;            // }            ListNode* temp=l1->next;            head->next=l1;            //n1->next=NULL; // NOTE: don't need to cut the tail of the new list            head=l1;            l1=temp;        }else {            ListNode* temp=l2->next;            head->next=l2;            head=l2;            l2=temp;        }    }    // 2. Check which list still has remaining nodes that are not added to new list.    if(l1==NULL) { // l2!=NULL, list 2 has remaining nodes.        head->next=l2;    }    else { // l1!=NULL, list 1 has remaining nodes.        head->next=l1;    }    return dummy->next;}// 103. Binary Tree Zigzag Level Order Traversal// Stack, bfs:// Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).// For example:// Given binary tree [3,9,20,null,null,15,7],//   3//  / \// 9  20//   /  \//  15   7// return its zigzag level order traversal as:// [//  [3],//  [20,9],//  [15,7]//  ]struct TreeNode {        int val;        TreeNode *left;        TreeNode *right;        TreeNode(int x) : val(x), left(NULL), right(NULL) {}    };// 1. Use 2 stacks as holders of nodes in each level. s1 holds nodes in odd number levels, s2 holds nodes in even number levels.// 2. Loop to pop the top node of s1 first until it has no more nodes remaining, explore top node as we pop it off,//   push its non NULL children into s2 in the order left -> right child// 3. Loop to pop the top node of s2 until it is empty, explore node as we pop it off,//    push its non NULL children into s1 in order right -> leftvector<vector<int>> zigzagLevelOrder(TreeNode* root) {    stack<TreeNode*> s1; // odd level    stack<TreeNode*> s2; // even level    vector<vector<int>> result;    if(root==NULL) return result;    s1.push(root);    while(!s1.empty() || !s2.empty()) {        vector<int> temp1;        while(!s1.empty()) {            TreeNode* n=s1.top();            s1.pop();            //cout<<"n:"<<n->val<<"\n";            temp1.push_back(n->val);            if(n->left!=NULL)                s2.push(n->left);            if(n->right!=NULL)                s2.push(n->right);                        if(s1.empty())                result.push_back(temp1);        }        vector<int> temp2;        while(!s2.empty()) {            TreeNode* n=s2.top();            s2.pop();            temp2.push_back(n->val);                        if(n->right!=NULL)                s1.push(n->right);            if(n->left!=NULL)                s1.push(n->left);            if(s2.empty())                result.push_back(temp2);        }    }    return result;}// 348. Design Tic-Tac-Toe// Design:// Design a Tic-tac-toe game that is played between two players on a n x n grid.//You may assume the following rules://  A move is guaranteed to be valid and is placed on an empty block.//  Once a winning condition is reached, no more moves is allowed.//  A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.class TicTacToe {public:    /** Initialize your data structure here. */    vector<vector<char>> board; // use 2d vector to be the board    int size;    TicTacToe(int n) {        board.resize(n,vector<char> (n));        size=n;    }    /** Player {player} makes a move at ({row}, {col}).     @param row The row of the board.     @param col The column of the board.     @param player The player, can be either 1 or 2.     @return The current winning condition, can be either:     0: No one wins.     1: Player 1 wins.     2: Player 2 wins. */    int move(int row, int col, int player) {        char p=player == 1 ? 'X' : 'O';        board[row][col]=p;        bool winV=true, winH=true, winD1=false, winD2=false;        // loop and check vertically and horizontally        for(int i=0; i<size; ++i) {            if(board[i][col]!=p) {                winV=false;                //break;            }            if(board[row][i]!=p) {                winH=false;                //break;            }            if(!winV&&!winH) break;        }        // diagonal        if(row==col) {            winD1=true;            for(int i=0; i<size; ++i) {                if(board[i][i]!=p) {                    winD1=false;                    break;                }            }        }        if(row==size-col-1) {            winD2=true;            for(int i=0; i<size; ++i) {                if(board[i][size-i-1]!=p) {                    winD2=false;                    break;                }            }        }        return (winV||winH||winD1||winD2)? player:0;    }};/** * Your TicTacToe object will be instantiated and called as such: * TicTacToe obj = new TicTacToe(n); * int param_1 = obj.move(row,col,player); */// 8. String to Integer (atoi)// String:int myAtoi(string str) {    int l=str.length();    if(l==0) return 0;    int num=0;    // count: the total length of the valid number, discarding the 0s in the front and before scaling to INT_MAX or INT_MIN for overflow (to determine wether there is overflow).    // sign: the count of total appearance of sign ('+' or '-') before index i.    // first: the value of the first valid digit (non-zero) (to determine wether there is overflow).    int count=0, sign=0, first=0;    // positive: wether the number is negative or positive.    // zero: wether we have met the first digit or sign.    bool positive=true,zero=false;    for(int i=0; i<l; ++i) {        // 1. Loop through all char in the string. Skip ' ' and '0' before appearance of the first digit or sign, or skip '0' when no non-zero digit appears before (num is 0).        while((str[i]==' ' && !zero)||(str[i]=='0' && !zero)  || (num==0 && str[i]=='0')) {            if(str[i]=='0') zero=true;            ++i;        }        char c=str[i];        // 2. If the current char c is a valid digit in the number (digit and non-zero before num has value, or '0' and non-zero after num > 0.        //     - check if it is the first valid digit, if so store it in first.        //     - increment the count of valid number length, count.        //     - calculate the updated value of number.        if(isdigit(c) ) {            if(count==0) first=c-'0';            ++count;            num=num*10+c-'0';        }        // 3. If current char is sign, '+' or '-'        //    - return 0 if there is '0' or other digit or sign before current sign.        //    - increment count of sign.        //    - swith bool positive to false if sign is '-'.        else if(c=='-' && num==0 && !zero) { // return 0 if there is '0' or other digit or sign before current '-'            ++sign;            positive=false;            if(sign>1) return 0;        }        else if(c=='+' && num==0 && !zero ) { // return 0 if there is '0' or other digit or sign before current '+'            ++sign;            if(sign>1) return 0;        }        // 4. Other cases, including '.' and ' ' after first appearance of digit or sign.        //   - Exit the loop and return num based on positive and overflow.        else if(c=='.') break;        else  break;        if(!zero) zero=true;    }        // 5. Check wether the number is negative or positive, and check if there is overflow,    // based on count (length of the valid number), num, and first (first digit value).    if(positive) {        // positive overflow:        if(count>10 || (count==10 && first>2 )|| (count==10 && num<0))            return INT_MAX;        else // regular positive number:            return num;    }    else{        // negative overflow:        if(count>10 || (count==10  && first>2) || (count==10 && num<0))            return INT_MIN;        else // regular negative number:            return -num;    }}// 151. Reverse Words in a String// String:// Given an input string, reverse the string word by word.// Example:// Input: "the sky is blue",// Output: "blue is sky the".// A helper function to reverse string from index i to index j.void reverseWord(string &s, int i, int j) {    while(i<j) {        char temp=s[i];        s[i++]=s[j];        s[j--]=temp;    }}void reverseWords(string &s) {    // j: current position of the old string.    // i: current position of the new string.    int i=0, j=0;    int l;    int len=s.length();    int wordCount=0;    while(i<len) {        // 1. Move j and find the next non-space char, the start point of a word.        while( s[j]==' ') ++j; // skip space before the first word        // 2. Exit if j is out of bound of string. Take care of the condition that there are spaces after the last word.        if(j>=len) break;        // 3. Put one space before the start of a new word to split each word. Don't put space if the current word is the frist word (wordCount == 0).        if(wordCount>0) s[i++]=' ';        // 3. l stores the start point of the current word that will be reversed.        l=i;        // 4. Pull the word from position j to position i.        while(j<len && s[j]!=' '){            s[i++]=s[j++];        }        // 5. i is the next index of the last char of the current word. Reverse the current word.        reverseWord(s, l, i-1);        ++wordCount;    }    // 6. Reverse the whole string from start to the end (i-1).    s.resize(i);    reverseWord(s, 0, i-1);}// O(n) time solution, O(1) space// function to reverse any part of string from i to j (just one word or entire string)void reverseword(string &s, int i, int j){    while(i<j){        char t=s[i];        s[i++]=s[j];        s[j--]=t;    }}void reverseWords2(string &s) {        int i=0, j=0;    int l=0;    int len=s.length();    int wordcount=0;        while(true){        while(i<len && s[i] == ' ') i++;  // skip spaces in front of the word        if(i==len) break;        if(wordcount) s[j++]=' ';        l=j;        while(i<len && s[i] != ' ') {s[j]=s[i]; j++; i++;}        reverseword(s,l,j-1);                // reverse word in place        wordcount++;            }        s.resize(j);                           // resize result string    reverseword(s,0,j-1);                  // reverse whole string}// 186. Reverse Words in a String II// The same algorithm as 151. Reverse Words in a String// Given an input string , reverse the string word by word.// Example:// Input:  ["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]// Output: ["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]// Note:// A word is defined as a sequence of non-space characters.// The input string does not contain leading or trailing spaces.// -> no test case like [" "," "]// The words are always separated by a single space.// NOTE: input string does not contain leading or trailing spaces// no test case such as [" "," "]void reverseWord(vector<char>& str, int i, int j) {    while(i<j) {        char temp=str[i];        str[i++]=str[j];        str[j--]=temp;    }}void reverseWords(vector<char>& str) {    int i=0, j=0, wordCount=0;    int len=str.size();    if(len<=1) return;    int l;    while(j<len) {        while(str[j]==' ') ++j;        if(j>=len) break;        if(wordCount>0) str[i++]=' ';        l=i;        while(j<len && str[j]!=' ') str[i++]=str[j++];        reverseWord(str, l, i-1);        ++wordCount;    }    str.resize(i);    reverseWord(str, 0, i-1);}// 445. Add Two Numbers II// Linked list://    You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.////    You may assume the two numbers do not contain any leading zero, except the number 0 itself.////    Follow up://    What if you cannot modify the input lists? In other words, reversing the lists is not allowed.////    Example://    Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)//    Output: 7 -> 8 -> 0 -> 7// method 1: Frist count number of nodes in list 1 and list 2,//          then add 0 padding nodes at the front of the shorter list.//          Add together each digit of the 2 lists after padding modification, using addDigits function.int carry=0;int countLists(ListNode* l1) {    if(l1->next==NULL) return 1;    return countLists(l1->next)+1;}// Helper function to add each digit of the 2 lists, considering carry in.ListNode* addDigits(ListNode* l1, ListNode* l2) {    if(l1->next==NULL && l2->next==NULL) {        if(l1->val+l2->val>=10) carry=1;        else carry=0;        ListNode* n=new ListNode((l1->val+l2->val)%10);        return n;    }    ListNode* n= addDigits(l1->next,l2->next);    ListNode* n1=new ListNode((l1->val+l2->val+carry)%10);    if(l1->val+l2->val+carry>=10) carry=1;    else carry=0;    n1->next=n;    return n1;}ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {    if(l1==NULL) return l2;    if(l2==NULL) return l1;    int c1=0, c2=0;    // 1. Count number of nodes in list 1 and list 2.    c1=countLists(l1);    c2=countLists(l2);    // 2. Set a dummy node to store the carry out (1) of the highest digit.    ListNode* head=new ListNode(0);    ListNode* h1=l1;    ListNode* h2=l2;    ListNode* temp=NULL;   // 3. Add extra 0 node at the front of the shorter list until 2 lists have the same length.    while(c1>c2){        temp=h2;        h2=new ListNode(0);        h2->next=temp;        ++c2;    }    while(c2>c1) {        temp=h1;        h1=new ListNode(0);        h1->next=temp;        ++c1;    }    // 4. Use helper function to add each digit of the 2 lists.    ListNode* n=addDigits(h1,h2);        head->next=n;    // 5. Check if the carry out of the highest digit is 1 or 0. If 1, set dummy node val to 1, else return the next node of the dummy node.    if(carry) {        head->val=1;        return head;    }    return head->next;}// method 2: fasterint carryIn=0;// Helper function to add each digit of the 2 lists, considering carry in.ListNode* addEachDigit(ListNode* l1, ListNode* l2) {    if(l1->next==NULL && l2->next==NULL) {        if(l1->val+l2->val>=10) carryIn=1;        else carryIn=0;        ListNode* n=new ListNode((l1->val+l2->val)%10);        return n;    }    ListNode* n= addEachDigit(l1->next,l2->next);    ListNode* n1=new ListNode((l1->val+l2->val+carryIn)%10);    if(l1->val+l2->val+carryIn>=10) carryIn=1;    else carryIn=0;    n1->next=n;    return n1;}ListNode* addTwoNumbers2(ListNode* l1, ListNode* l2) {    if(l1==NULL) return l2;    if(l2==NULL) return l1;    // 1. Set a dummy node to store the carry out (1) of the highest digit.    ListNode* head=new ListNode(0);    ListNode* h1=l1;    ListNode* h2=l2;    ListNode* temp=NULL;    // 2. Add extra 0 padding nodes at the front of the shorter list until 2 lists have the same length (2 pointers l1 and l2 are both NULL pointers).    while(l1!=NULL || l2!=NULL) {        if(l1!=NULL && l2!=NULL) {            l1=l1->next;            l2=l2->next;        }        else {            if(l1==NULL) {                temp=h1;                h1=new ListNode(0);                h1->next=temp;                l2=l2->next;            }else {                temp=h2;                h2=new ListNode(0);                h2->next=temp;                l1=l1->next;            }        }    }    // 3. Use helper function to add each digit of the 2 lists. And add the head pointer of the result list to the end of the dummy node.    ListNode* n=addEachDigit(h1,h2);    head->next=n;    // 4. Check if the carry out of the highest digit is 1 or 0. If 1, set dummy node val to 1, else return the next node of the dummy node.    if(carryIn) {        head->val=1;        return head;    }    return head->next;}// similar problem:// 2. Add Two Numbers// difference between II: the lists are in the order from least significant to most significant.//    You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.////    You may assume the two numbers do not contain any leading zero, except the number 0 itself.////    Example://    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)//    Output: 7 -> 0 -> 8//    Explanation: 342 + 465 = 807.ListNode* addTwoNumbers3(ListNode* l1, ListNode* l2){    ListNode* dummyHead = new ListNode(0);    ListNode* p = l1;    ListNode* q = l2;    ListNode* curr = dummyHead;    int x,y=0;    int carry = 0;    while (p != nullptr || q != nullptr) {        if(p==nullptr)            x =0;        else            x=p->val;        if(q==nullptr)            y=0;        else            y=q->val;        int sum = carry + x + y;        carry = sum / 10;        curr->next = new ListNode(0);        curr->next->val=sum%10;        curr = curr->next;        if (p != nullptr) p = p->next;        if (q != nullptr) q = q->next;    }    if (carry > 0) {        curr->next = new ListNode(carry);    }    return dummyHead->next;}// 24. Swap Nodes in Pairs// Linked list:// Given a linked list, swap every two adjacent nodes and return its head.// Example:// Given 1->2->3->4, you should return the list as 2->1->4->3.// Note:// Your algorithm should use only constant extra space.// You may not modify the values in the list's nodes, only nodes itself may be changed.ListNode* swapPairs(ListNode* head) {    if(head==NULL || head->next==NULL) return head;    ListNode* h=head;    ListNode* temp;    ListNode* prev=NULL;    // 1. Move through the list 2 nodes at a time.    // head points to the first node of the current pair, head -> next is the second node of the current pair.    while(head!=NULL && head->next!=NULL) {        ListNode* n1=head;        ListNode* n2=head->next;        temp=head->next->next;        // 3. If the current pair is the first pair, save the head pointer of the new list.        // If the current pair is not the first pair, connect the tail of the last pair to the head of the current pair.        if(prev==NULL)            h=n2;        else            prev->next=n2;                n2->next=n1;        n1->next=temp;        // 4. save the last node of the previous pair        prev=n1;        head=temp;    }    return h;}// faster version:ListNode* swapPairs2(ListNode* head) {    if(head==NULL || head->next==NULL) return head;        ListNode* temp;    ListNode* prev=new ListNode(0);    ListNode* h=prev;    while(head!=NULL && head->next!=NULL) {        ListNode* n1=head;        ListNode* n2=head->next;        temp=head->next->next;        prev->next=n2;                n2->next=n1;        n1->next=temp;                prev=n1;        head=temp;    }    return h->next;}// 223. Rectangle Area// Math:// Find the total area covered by two rectilinear rectangles in a 2D plane.// Example:// Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2// Output: 45int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {    // 1. Calculate the sum of the 2 rectangle areas.    int area=abs(A-C)*abs(B-D)+abs(E-G)*abs(F-H);    int overlap=0;    // 2. Calculate overlapping area.    // If (E,F) is on the lower left side of (C,D) && (G,H) is on the up right of (A,B), we know that there must be overlap between 2 rectangles.    // NOTE: need to consider the condition that G<A, no overlapping.    if(E<C && F<D && H>B && G>A)        overlap=(abs(max(A,E)-min(C,G))*abs(max(B,F)-min(D,H)));    // 3. Return the sum of the 2 areas minus the overlapping area.    return area-overlap;}// 623. Add One Row to Tree// Tree:// Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.// The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.//    Input://    A binary tree as following://        4//      /   \//     2     6//    / \   ///   3   1 5////    v = 1//    d = 2////    Output://        4//       / \//      1   1//     /     \//    2       6//   / \     ///  3   1   5// NOTE: If d is 1, the left subtree of the added node is the original tree under root, the right subtree of the added node is NULL.void nodesAtDepth(vector<TreeNode*> &result, TreeNode* root, int a, int d) {    if(root==NULL) return;    if(a==d) {        result.push_back(root);        return;    }    nodesAtDepth(result,root->left, a+1, d);    nodesAtDepth(result,root->right, a+1, d);    }TreeNode* addOneRow(TreeNode* root, int v, int d) {    vector<TreeNode*> result;    if(d==1) {        TreeNode* head=new TreeNode(v);        head->left=root;        return head;    }    nodesAtDepth(result,root,1,d-1);    int size=result.size();    for(int i=0; i<size; ++i) {        TreeNode* curr=result[i];        TreeNode* tempLeft=curr->left;        TreeNode* tempRight=curr->right;        curr->left=new TreeNode(v);        curr->right=new TreeNode(v);        curr->left->left=tempLeft;        curr->right->right=tempRight;    }    return root;}// 54. Spiral Matrix// Array:vector<int> spiralOrder(vector<vector<int>>& matrix) {    vector<int> result;    // 1. Use row and col to keep track of the current upper bound of the row and column index after printing each col or row. After printing out the right most column, we need to decrement col, and after printing out the bottom most row, we need to decrement row.    int row=matrix.size();    if(row==0) return result; // NOTE: do this step before access matrix[0]!    int col=matrix[0].size();    // 2. Use colStart and rowStart to keep track of the lower bound of the row and column. After printing out the left most column, increment colStart. After printint out the top most row, increment rowStart.    int colStart=0;    int rowStart=0;    int i=0;    // 3. Loop through the outer most layer of the matrix in 4 directions, right, down, left, up. Update the boundary of the matrix after each direction. Exit the loop when the lower bound of col meets the upper bound of col, or the lower bound of row meets the upper bound of row.    while(colStart<col && rowStart<row){        switch(i%4) {            case 0:                for(int j=colStart; j<col; ++j)                    result.push_back(matrix[colStart][j]);                ++rowStart;                break;            case 1:                for(int j=rowStart; j<row; ++j)                    result.push_back(matrix[j][col-1]);                --col;                break;            case 2:                for(int j=col-1; j>=colStart; --j)                    result.push_back(matrix[row-1][j]);                --row;                break;            case 3:                for(int j=row-1; j>=rowStart; --j)                    result.push_back(matrix[j][colStart]);                ++colStart;                break;        }        ++i;    }    return result;    }int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}