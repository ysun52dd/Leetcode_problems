Facebook//  Facebook////  Created by SunYutong on 8/15/18.//  Copyright © 2018 SunYutong. All rights reserved.//#include <iostream>#include <string>#include <vector>#include <stack>#include <math.h>#include <queue>#include <unordered_map>using namespace std;// 91. Decode Ways ********************// Dynamic programming:// A message containing letters from A-Z is being encoded to numbers using the following mapping://    'A' -> 1//    'B' -> 2//    ...//    'Z' -> 26//    Given a non-empty string containing only digits, determine the total number of ways to decode it.// Input: "12"// Output: 2// Explanation: It could be decoded as "AB" (1 2) or "L" (12).//dp?????int numDecodings(string s) {    int l=s.length();    if(l==0) return 0;    int dp[l+1]={0};    // 1. Set a dp array to store number of decode ways for string before index i (not including).    // 2. initialize the first element of dp[] to 1, since number of possible ways to divide empty string into numbers from 1 to 26 is only 1.    dp[0]=1;    // 3. Loop through all l char of string s, and calculate the number fo decode ways until i and store it in dp[i+1].    for(int i=0; i<l; ++i) {        // 4. Function to calculate dp[i+1]:        // Condition 1: Decode s[i] individually. If current char s[i] is not '0', we can decode itself, so in this condition dp[i+1] has the value of dp[i].        if(s[i]!='0') dp[i+1]+=dp[i];        // Condition 2: Decode s[i] together with s[i-1]. If s[i] is not the first char and s[i-1] is usable (not '0') and the combination of s[i-1] and s[i] is within 26, we can decode s[i] s[i-1] as 1 letter, so in this case dp[i+1] = dp[i-1].        if(i>=1 && s[i-1]!='0' && (s[i-1]-'0')*10 + s[i]-'0' <=26)            dp[i+1]+=dp[i-1];        // Combine the 2 conditions: dp[i+1]=dp[i]+dp[i-1] if both cases are legal.    }    // 5. The number of decode ways to the last char is in dp[l]    return dp[l];}// 20. Valid Parentheses// Stack:// Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.//    An input string is valid if://    Open brackets must be closed by the same type of brackets.//    Open brackets must be closed in the correct order.//    Note that an empty string is also considered valid.////    Example 1:////    Input: "()"//    Output: truebool isValid(string s) {    if(s.length()==0) return true;    if(s.length()==1) return false;    stack<char> st;    for(int i=0; i<s.length(); ++i) {        switch(s[i]){            case ')':                if(st.empty() || st.top()!='(') return false;                st.pop();                break;            case ']':                if(st.empty() || st.top()!='[') return false;                st.pop();                break;            case '}':                if(st.empty() || st.top()!='{') return false;                st.pop();                break;            default:                st.push(s[i]);        }    }    return st.empty();}// 301. Remove Invalid Parentheses (hard)// DFS, BFS://Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.//Note: The input string may contain letters other than the parentheses ( and ).////Example 1://Input: "()())()"//Output: ["()()()", "(())()"]// DFS method:// 1.??????String????????????// 2.??????String???????????????????????????????????String??DFS?????????????????????????????// 3.DFS??????????????????0vector<int> getLeftRightCount(string s) {    vector<int> count(2,0);    for(auto c:s) {        if(c=='(') // 1. if we meet a '(', increment the left count.            count[0]++;        if(c==')') { // 2. if we meet a ')' and the left count is not 0, match ')' with '(' and decrement the right count.            if(count[0]>0)                count[0]--;            else // 3. if we meet a ')' but there is no '(' before to match it, increment the right count.                count[1]++;        }    }    return count;}bool isValidParentheses(string s) {    vector<int> count=getLeftRightCount(s);    return count[0]==0 && count[1]==0;}void dfs(string s, int startIndex, int leftCount, int rightCount, vector<string> &result) {    // 1. Exit the recursion if all '(' match ')' (left count and right count are 0 and string s is a valid sequence of parentheses).    if(leftCount==0 && rightCount==0 && isValidParentheses(s)) {        result.push_back(s);        return;    }    // NOTE: use this loop unrolling method to improve performance and don't use .length() function inside the for loop.    int l=s.length();    for(int i=startIndex; i<l; ++i) {        // 2. Skip the case that the parenthese is not the 1st in a consecutive list of the same parentheses. (Avoid repeated answer in the result string)        if(i>startIndex && s[i]==s[i-1]) continue;        if(leftCount>0 && s[i]=='(') // 3. make sure leftCount is > 0, make sure least number of parentheses are removed            // 4. remove the s[i] char, and decrease the left parentheses count, and do dfs for the string without s[i] again.            // NOTE: Don't use --leftCount or leftCount-- in recursion functions, since these 2 will change the leftCount value after this function returns and influence the input value of other function calls.            dfs(s.substr(0,i)+s.substr(i+1), i, leftCount-1, rightCount, result);        if(rightCount>0 && s[i]==')') // same as step 4 for ')'            dfs(s.substr(0,i)+s.substr(i+1), i, leftCount, rightCount-1, result);    }}vector<string> removeInvalidParentheses(string s) {    vector<string> result;    // 1. First get the count of left parentheses and right parentheses.    vector<int> count=getLeftRightCount(s);    // 2. recursively do dfs from the start of the string, and pass in the entire string s and the left count and right count just calculated.    dfs(s, 0, count[0], count[1], result);    return result;}// 125. Valid Palindrome// String:// Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.//Note: For the purpose of this problem, we define empty string as valid palindrome.////Example 1:////Input: "A man, a plan, a canal: Panama"//Output: truebool isPalindrome(string s) {    for (auto & c: s) c = isalpha(c) || isdigit(c) ? tolower(c) : ' ';    s.erase(remove(s.begin(), s.end(), ' '), s.end());    int left=0, right=s.length()-1;    while(left<=right) {        if(left<=right && s[left]!=s[right]) return false;        ++left;        --right;    }    return true;}// faster solution:bool isPalindrome2(string s) {    transform(s.begin(), s.end(), s.begin(), ::tolower);    int left=0, right=s.length()-1;    while(left<=right) {        if(!::isalnum(s[left])) ++left;        else if(!::isalnum(s[right])) --right;        else if( s[left]!=s[right]) return false;        else {            ++left;            --right;        }    }    return true;}// 29. Divide Two Integers// Binary search:// Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.//// Return the quotient after dividing dividend by divisor.// The integer division should truncate toward zero.//// Example 1:// Input: dividend = 10, divisor = 3// Output: 3// Keep subtract the divisor from the dividend.// 1. If the divisor, b, is < dividend, a, modify divisor by multiplying 2 (shift to the left by 1 since we are not allowed to use multiplication operator) until b is greater than a.// 2. Subtract a by the multiplication of b which just below a, and record the multiplication (shift) of b in result.int divide(int dividend, int divisor) {    // Special case:    if(dividend==INT_MIN && divisor==-1) return INT_MAX;        bool isNegative = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0);        long a = abs((long)dividend);    long b = abs((long)divisor);    int result = 0;    while(a >= b){        int shift = 0;        // 1.        while(a >= (b << shift)){            shift++;        }        // 2.        a -= b << (shift - 1);        result += 1 << (shift - 1);    }    return isNegative? -result :result;}// 31. Next Permutation//    Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.////    If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).////    The replacement must be in-place and use only constant extra memory.////    Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.////    1,2,3 ? 1,3,2//    3,2,1 ? 1,2,3//    1,1,5 ? 1,5,1// A function that reverses the vector nums from index i to the end of the vector using XOR operator.void reverse(vector<int>& nums, int i) {    int left=i,right=nums.size()-1;    while(left<right) { // NOTE: can't be left<=right!!!        nums[left] ^= nums[right];        nums[right] ^= nums[left];        nums[left] ^= nums[right];        ++left;        --right;    }}// test case:// [1,2,3,7,6,5]// output: [1,2,5,3,6,7]//         [1,2,3,7,6,5] ->swap 3 and 5//              i     j//         [1,2,5,7,6,3] -> reverse from 7 to 3// output: [1,2,5,3,6,7]void nextPermutation(vector<int>& nums) {    int size=nums.size();    // NOTE: need to consider the condition that only 1 element in vector    if(size<2) return;    // 1. Loop from the back of the vector to find the first number that is < than its next number. And store its position as i.    int i=size-2;    while(i>=0 && nums[i]>=nums[i+1]) {        --i;    }    // 2. The case that the current number that vector shows is the largest permutation. Return the reverse permutation of the vector (the smallest permutation).    if(i<0) {        reverse(nums, 0);        return;    }    // 3. Loop to the right of i to find the last element, nums[j], that is > nums[i]    int j=i+1;    while(j<size && nums[j]>nums[i])        ++j;    --j;       // 4. Swap 2 elements at position i and j. swap 2 elements in vector using XOR    nums[i] ^= nums[j];    nums[j] ^= nums[i];    nums[i] ^= nums[j];        // NOTE: need to take care of the condition that position nums[i] and nums[j] are not the last 2 elements in nums (nums[i] is not the one before last element).    if(i!=size-2)    // 5. Reverse the vector after index i (i+1 to size-1). Skip this step unless i == size-2. Can't swap the same element with itself, it will become 0.        reverse(nums, i+1);}// 67. Add Binary//    Given two binary strings, return their sum (also a binary string).////    The input strings are both non-empty and contains only characters 1 or 0.////    Example 1:////    Input: a = "11", b = "1"//    Output: "100"string addBinary(string a, string b) {    int i=a.length()-1,j=b.length()-1;    int c=0; // carry in    string s;    while(i>=0 || j>=0 || c==1) {        c+= i>=0 ? a[i--] -'0': 0;        c+= j>=0 ? b[j--] -'0': 0;        s=s+char(c%2+'0');        c=c/2;    }    reverse(s.begin(),s.end());    return s;}// jiuzhang solution:string addBinary2(string a, string b) {    string result;    const size_t n = a.size() > b.size() ? a.size() : b.size();    reverse(a.begin(), a.end());    reverse(b.begin(), b.end());    int carry = 0;    for (size_t i = 0; i < n; i++) {        const int ai = i < a.size() ? a[i] - '0' : 0;        const int bi = i < b.size() ? b[i] - '0' : 0;        const int val = (ai + bi + carry) % 2;        carry = (ai + bi + carry) / 2;        result.insert(result.begin(), val + '0');    }    if (carry == 1) {        result.insert(result.begin(), '1');    }    return result;}// 253. Meeting Rooms II// Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.// Example 1://    Input: [[0, 30],[5, 10],[15, 20]]//    Output: 2struct Interval {        int start;        int end;        Interval() : start(0), end(0) {}        Interval(int s, int e) : start(s), end(e) {}    };bool cmp(Interval a, Interval b) {    return a.end<b.end;}int minMeetingRooms(vector<Interval>& intervals) {    int size=intervals.size();        if(size<2) return size;    int count=1,max=INT_MIN;    sort(intervals.begin(), intervals.end(), cmp);    for(int i=0; i<intervals.size(); ++i) {        Interval temp=intervals[i];        for(int j=i+1; j<intervals.size(); ++j) {            if(intervals[j].start<intervals[i].end) {                count++;            }                    }        max=fmax(max,count);        count=1;    }    return max;}// O(n) Solution:// 1. Sort the intervals based on start time from small to largebool cmp2(Interval a, Interval b) {    return a.start<b.start;}int minMeetingRooms2(vector<Interval>& intervals) {        int size=intervals.size();        if(size<2) return size;        int count=1,max=INT_MIN;        sort(intervals.begin(), intervals.end(), cmp2);        priority_queue<int, vector<int>, greater<int>> min_heap;    // 2. Loop through all intervals, keep track of the earliest end time of all checked intervals in min_heap.        for(int i=0; i<intervals.size(); ++i) {            // 3. Pop the interval that ends earliest if the current interval's start time is after the earliest end time, and push the current interval in min_heap. (just like change the old interval with a new interval that is in same line, or can use the same meeting room as the old interval)            // !min_heap.empty() eliminate the condition that it is the first element in intervals and the min_heap is empty            if(!min_heap.empty() && intervals[i].start>=min_heap.top()) min_heap.pop();            // 4. If one interval has a start time early than the earliest end time, it can't be in the same line (overlapping) as the interval with earliest end time, then it must also overlap with intervals that overlap with the interval with earliest end time.            min_heap.push(intervals[i].end);                        // max=fmax(max,count);            //    count=1;        }    // 5. return the size of the min_heap, size of min_heap shows the number of lines (meeting rooms) that all the intervals can be arranged in.        return min_heap.size();    }// 17. Letter Combinations of a Phone Number// Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.// A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.// Input: "23"// Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].vector<string> letterCombinations(string digits) {    }// DFS:void dfs(int i, int l, string s, string digits,vector<string> map, vector<string>& result) {    if(i==l) {        result.push_back(s);        return;    }    for(auto c:map[digits[i]-'0']) {        dfs(i+1, l, s+c, digits, map, result);    }}vector<string> letterCombinations2(string digits) {    vector<string> result;    int l=digits.length();    if(l==0) return result;    string s;    vector<string> map={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};    dfs(0, l, s, digits, map, result);    return result;}// Valid Palindrome II// Two pointers:bool validPalindrome(string s) {    int l=s.length();    if(l<3) return true;    int left=0, right=l-1;    int count=0;    while(left<=right) {        if( s[left]!=s[right]) {            if(count>=1) return false;            else{                                if(s[left+1]==s[right] && (left+2>right-1 || s[left+2]==s[right-1]))                {++left;                    ++count;}                else if(s[left]==s[right-1] && (left+1>right-2 ||s[left+1]==s[right-2]))                { --right;                    ++count;}                else return false;            }        }        ++left;        --right;    }    return true;}// method 2: clear versionbool isPalindrome(string s, int left, int right) {    while(left<=right) {        if(s[left]!=s[right])            return false;        ++left;        --right;    }    return true;}bool validPalindrome2(string s) {    int l=s.length();    if(l<3) return true;    int left=0, right=l-1;    int count=0;    while(left<=right) {        if( s[left]!=s[right]) {            return isPalindrome(s, left+1, right) || isPalindrome(s, left, right-1);        }        ++left;        --right;    }    return true;}// 56. Merge Intervals// Greedy://struct Interval {//        int start;//        int end;//        Interval() : start(0), end(0) {}//        Interval(int s, int e) : start(s), end(e) {}//    };bool cmp3(Interval a, Interval b) {    return a.start<b.start;}vector<Interval> merge(vector<Interval>& intervals) {    vector<Interval> result;    int size=intervals.size();    if(size<2) return intervals;    sort(intervals.begin(), intervals.end(), cmp3);    int start=intervals[0].start;    int end=intervals[0].end;    for(int i=1; i<size; ++i) {                if(intervals[i].start>end) {            //if(i!=0) {            Interval temp(start, end);            result.push_back(temp);            start=intervals[i].start;            end=intervals[i].end;        }else            end=fmax(end, intervals[i].end);    }        result.push_back(Interval(start, end));    return result;}// 227. Basic Calculator II// String, stack// Implement a basic calculator to evaluate a simple expression string.// The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.//Input: "3+2*2"//Output: 7int calculate(string s) {    int l=s.length();    if(l==0) return 0;    stack<int> stack;    // 1. Set the initial sign to '+'.    int num=0;    char sign='+';    for(int i=0; i<l; ++i) {        char c=s[i];        // 2. Store number into integer num.        if(isdigit(c))            num=num*10+c-'0';        // 3. If current char is a sign (the end of a number), do the operation stored in sign for the top of the stack and the number before current char c.        if(c!=' ' && !isdigit(c) || i==l-1) {            switch(sign) {                case '+':                    stack.push(num);                    break;                case '-': // if the last sign is '-', push the negative number of num                    stack.push(-num);                    break;                case '*': // if the last sign is '*' or '/', get the result by doing the operation for stack top and current number, and then push the result back.                    num*=stack.top();                    stack.pop();                    stack.push(num);                    break;                case '/':                    num=stack.top()/num;                    stack.pop();                    stack.push(num);                    break;            }            // 4. Set the current number back to 0 if we meet the end of a number (a new sign), set the last sign to the current sign.            num=0;            sign=c;        }    }    // 5. Pop all numbers in the stack off, sum them up to get the final result.    while(!stack.empty()) {        num+=stack.top();        stack.pop();    }    return num;}// 121. Best Time to Buy and Sell Stock// Say you have an array for which the ith element is the price of a given stock on day i.// If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.// Note that you cannot sell a stock before you buy one.int maxProfit(vector<int>& prices) {    int size=prices.size();    if(size<2) return 0;    int min=INT_MAX;    int maxPro=INT_MIN;    for(auto p:prices) {        min=fmin(min,p);        maxPro=fmax(maxPro,p-min);    }    return maxPro;}// 273. Integer to English Words (hard)// String:// Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2^31 - 1.// Input: 123// Output: "One Hundred Twenty Three"// Input: 1234567891// Output: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"// Improved version:string numberToWords2(int num) {    string result;    // NOTE: Special case: if num is 0, return "Zero"!!!    if(num==0) return "Zero";    vector<string> dict={"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};    vector<string> dictTen={"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};    vector<string> dictHundred={"Hundred", "Thousand", "Million", "Billion"};    // 1. Use temp to record the value every thousand (3 digits), if temp is in the range larger than 1 billion, from million to billion, from thousand to million we can put "Billion", "Million", "Thousand" at the end of the outer loop.    int temp=num;    for(int i=1000000000; i>=1; i/=1000) { // i changes every 1 thousand.        for(int j=100; j>=1; j/=10) { // j loops through every bit in 1 thousand.            // Skip the following steps if the divisor is > 10^9. (start checking from billion since num is < 2^31 - 1). If we do not do this, overflow!!!            if(i*j>1000000000) continue;            // 2. n is the current digit from left to right in num, or the unit digit if we move the floating point to the left by i*j.            int n=num/(i*j);            if(n<=0) continue;            // Hundreds digit:            if(j==100) {                if(!result.empty()) result+=" ";                result+=dict[n]+" "+dictHundred[0];            }            // Tens digit:            if(j==10) {                if(n>=2) {                    if(!result.empty()) result+=" ";                    result+=dictTen[n];                }                else continue; // If the tens digit is <2, use eleven to twenty, and keep num the same to the next digit.            }            // Units digit:            if(j==1) {                if(!result.empty()) result+=" ";                result+=dict[n];            }            // 3. Delete the current digit from num by doing mod operation with the current divisor i*j            num%=(i*j);        }        // 4. Check once every 1000, decide whether to put Thousand, Million, Billion in the string.        if(i==1000000000 && temp>=i)            result+=" "+dictHundred[3];        if(i==1000000 && temp>=i && temp<i*1000)            result+=" "+dictHundred[2];        if(i==1000 && temp>=i && temp<i*1000) result+=" "+dictHundred[1];        // 5. Update the value of temp every 1 thousand.        temp%=i;    }    return result;}// Original version:string numberToWords(int num) {    string result;    if(num==0) return "Zero";    vector<string> dict={"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};    vector<string> dictTen={"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};    vector<string> dictHundred={"Hundred", "Thousand", "Million", "Billion"};    int temp=num;    for(int i=1000000000; i>=1; i/=1000) {        if(i==1000000000) {            int n=num/i;            if(n==1) {                result+="One Billion";                num%=i;                temp%=i;            }            if(n==2) {                result+="Two Billion";                num%=i;                temp%=i;            }        }        else {            for(int j=100; j>=1; j/=10) {                int n=num/(i*j);                if(n>0) {                    if(j==100) {                        if(!result.empty()) result+=" ";                        result+=dict[n]+" "+dictHundred[0];                        num%=(i*j);                    }                    if(j==10) {                        if(n>=2) {                            if(!result.empty()) result+=" ";                            result+=dictTen[n];                            num%=(i*j);                        }                        else continue;                    }                    if(j==1) {                        if(!result.empty()) result+=" ";                        result+=dict[n];                        num%=i;                    }                }                if(j==1) {                    if(i==1000000 && temp>=i && temp<i*1000){                        result+=" "+dictHundred[2];                        temp%=1000000;                    }                    if(i==1000 && temp>=1000 && temp<i*1000) result+=" "+dictHundred[1];                                    }            }        }    }    return result;}// jiuzhang solution:string convertHundred(int num) {    vector<string> v1 = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};    vector<string> v2 = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};    string res;    int a = num / 100, b = num % 100, c = num % 10;    res = b < 20 ? v1[b] : v2[b / 10] + (c ? " " + v1[c] : "");    if (a > 0) res = v1[a] + " Hundred" + (b ? " " + res : "");    return res;}string numberToWords3(int num) {    string res = convertHundred(num % 1000);    vector<string> v = {"Thousand", "Million", "Billion"};    for (int i = 0; i < 3; ++i) {        num /= 1000;        res = num % 1000 ? convertHundred(num % 1000) + " " + v[i] + " " + res : res;    }    while (res.back() == ' ') res.pop_back();    return res.empty() ? "Zero" : res;}// 10. Regular Expression Matching (very hard!!!)// DP using 2d array:// Similar to Wildcard Matching// Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.// '.' Matches any single character.// '*' Matches zero or more of the preceding element.//   Input://    s = "ab"//    p = ".*"//   Output: true//   Explanation: ".*" means "zero or more (*) of any character (.)".//   Input://    s = "aab"//    p = "c*a*b"//   Output: true//   Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".// ********* Best solution!!!: O(n^2), 4ms ***********//    1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];//    2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];//    3, If p.charAt(j) == '*'://      here are two sub conditions://          1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty//          2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.'://              dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a//              or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a//              or dp[i][j] = dp[i][j-2]   // in this case, a* counts as emptybool isMatch2(string s, string p) {    int sl=s.length();    int pl=p.length();    vector<vector<bool>> dp(sl+1,vector<bool>(pl+1,0));    // bool[][] dp = new boolean[s.length()+1][p.length()+1];    dp[0][0] = true;    for (int i = 0; i < p.length(); i++) {        if (p[i] == '*' && dp[0][i-1]) {            dp[0][i+1] = true;        }    }    for (int i = 0 ; i < s.length(); i++) {        for (int j = 0; j < p.length(); j++) {            if (p[j] == '.') {                dp[i+1][j+1] = dp[i][j];            }            if (p[j] == s[i]) {                dp[i+1][j+1] = dp[i][j];            }            if (p[j] == '*') {                if (p[j-1] != s[i] && p[j-1] != '.') {                    dp[i+1][j+1] = dp[i+1][j-1];                } else {                    dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);                }            }        }    }    return dp[sl][pl];}// *************************************************// Second best solution: 8ms// Wildcard Matching ???????: ??????Memoization Search?bool isEmpty(string p, int pIndex) {    for (int i = pIndex; i < p.length(); i += 2) {        if (i + 1 >= p.length() || p[i + 1] != '*') {            return false;        }    }    return true;}bool charMatch(char s, char p) {    return s==p || p=='.';}bool isMatchHelper(string s, int sIndex,                   string p, int pIndex,                   vector<vector<bool>>& memo,                   vector<vector<bool>>& visited) {    // "" == ""    // If we reach the end of p string, we can say that s does not match p if there are more char in s.    if (pIndex == p.length()) {        return sIndex == s.length();    }    // If we reach the end of s, check is the rest of the string p in the form X*X*...    if (sIndex == s.length()) {        return isEmpty(p, pIndex);    }        if (visited[sIndex][pIndex]) {        return memo[sIndex][pIndex];    }        char sChar = s[sIndex];    char pChar = p[pIndex];    bool match;        // consider a* as a bundle    if (pIndex + 1 < p.length() && p[pIndex + 1] == '*') {        match = isMatchHelper(s, sIndex, p, pIndex + 2, memo, visited) ||        charMatch(sChar, pChar) && isMatchHelper(s, sIndex + 1, p, pIndex, memo, visited);    } else {        match = charMatch(sChar, pChar) &&        isMatchHelper(s, sIndex + 1, p, pIndex + 1, memo, visited);    }        visited[sIndex][pIndex] = true;    memo[sIndex][pIndex] = match;    return match;}bool isMatch(string s, string p) {    int sl=s.length();    int pl=p.length();    if(p==".*") return true;    if(sl==0) return isEmpty(p,0);        vector<vector<bool>> memo(sl,vector<bool>(pl,0));    vector<vector<bool>> visited(sl,vector<bool>(pl,0));        return isMatchHelper(s, 0, p, 0, memo, visited);}// Very slow recursion solution:bool isMatch3(string s, string p) {    if (s.length() == 0){        // s???????????p????? "X*X*"???        if (p.length() & 1) return false;        else {            for (int i = 1; i < p.length(); i += 2) {                if (p[i] != '*') return false;            }        }        return true;    }    if (p.length() == 0) return false;    if (p.length() > 1 && p[1] == '*') {        if (p[0] == '.' || s[0] == p[0]) {            return isMatch(s.substr(1), p) || isMatch(s, p.substr(2));        } else return isMatch(s, p.substr(2));    } else {        if (p[0] == '.' || s[0] == p[0]) {            return isMatch(s.substr(1), p.substr(1));        } else return false;    }}// WRONG!!!bool isMatch4(string s, string p) {    int l=s.length();    if(l==0) return p.length()==0 ? true:false;    if(p==".*") return true;    int curr=0;    int lp=p.length();    for(int i=0; i<l; ++i) {        char c=s[i];        if(curr>=lp) {            return false;        }        if(p[curr]=='.') {            if(curr==lp-1) return true;            ++curr;        }        else if(isalpha(p[curr])){            if(c!=p[curr] ) {                if(curr+1>=lp || (curr+1<lp && p[++curr]!='*')) {                    return false;                }                if(p[curr]=='*' && p[curr+1]!=c && p[++curr]!='.')                    return false;            }            ++curr;        }        else if(p[curr]=='*') {            if(curr-1<0) return false;            if (p[curr-1]!=c && p[curr-1]!='.' )            {                if (++curr>=lp  || (p[curr++]!='.' && p[curr-1]!=c))                                       return false;                            } else if(i==l-1)                ++curr;        }    }    return p[curr]=='\0' || p[curr]=='*';}// 543. Diameter of Binary Tree// Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.//     1//    / \//   2   3//  / \// 4   5// Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].struct TreeNode {        int val;        TreeNode *left;        TreeNode *right;        TreeNode(int x) : val(x), left(NULL), right(NULL) {}    };// bfs returns the max depth below node root. Also update the max path which is the sum of depth below left child and depth below right child.int bfs(TreeNode* root, int &max) {    if(root==NULL) return 0;    // 1. Find 2 depth numbers below root's left child and right child.    int left=bfs(root->left, max);    int right=bfs(root->right, max);    // 2. Check wether the sum of the max depth from its left child and right child is a max within all nodes in the tree.    max=fmax(left+right, max);    // 3. Use the max depth between left child and right child, increment the depth by 1.    return fmax(left, right)+1;}int diameterOfBinaryTree(TreeNode* root) {    if(root==NULL) return 0;    int max=INT_MIN;    int result=bfs(root, max);    return max;}// 438. Find All Anagrams in a String// Hash table:// Sliding window problem:// Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.// Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.// The order of output does not matter.// https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem.vector<int> findAnagrams(string s, string p) {    int lp=p.length();    int ls=s.length();    vector<int> result;    if(lp>ls) return result;    // 1. Hash table stores how many key chars is available to be later added into the sliding window for each char in string p. Loop through the string p to set up the hash table, the value mapped to the key char is the count of it in p.    unordered_map<char, int> map;    for(auto c:p) {        map[c]++;    }    // counter stores how many unique char we still need to fullfill string p.    int counter = map.size();    int begin = 0, end = 0;    while(end < ls){        // 2. Check the end char in the string window, update the count in hash table and the counter.        char c = s[end];        if( map.find(c)!=map.end() ){            map[c]--;            if(map[c] == 0) counter--; // if the entering char takes up all its places in p string, reduce the counter.        }        // move the end pointer        end++;        // 3. Enter this loop only if at least a part of the string from begin to end-1 is the anagram of string p (counter==0). Move back the begin pointer and check wether removing s[begin] can give us the chance to add in more char ,that is in the hash table, to the end of the window. If s[begin]        while(counter == 0){            // (1) If there is no remaining char in p that is not satisified by string s from begin to end-1 (including begin, end-1), check if the length of it reaches lp. If so, push the begin position into result.            if(end-begin == lp){                result.push_back(begin);            }            // (2) Remove the char at postion begin in the sliding window, update the hash table.            //      - If s[begin] is in the hash table, increase its available count, map[s[begin]] by 1            //         If after the above modification the available count is above 0, there is one more unique char that we can add into the window (increase counter by 1).            char tempc = s[begin];            if(map.find(tempc)!=map.end()){                map[tempc]++;                if(map[tempc] > 0){                    counter++;                }            }            // (3) Move the begin pointer            begin++;        }    }    return result;}// 76. Minimum Window Substring// Hash table, two pointers:// Sliding window://Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).////Example:////Input: S = "ADOBECODEBANC", T = "ABC"//Output: "BANC"string minWindow(string s, string t) {    int ls=s.length();    int lt=t.length();    int minLength=INT_MAX, minIndex=0;    if(ls==0 || lt==0 || ls<lt) return "";    unordered_map<char, int> map;    // 1. Loop throught the string t, map all its char with a count.    for(auto c: t)        ++map[c];    // 2. counter is the number of unique char that can be add into the window to match stirng t. counter is the total number of unique char in t before we start to check the string s.    int counter=map.size();    int left=0, right=0;    // 3. Loop through the string s, move the right pointer, check if s[right] is available in the map. If so, decrement its count, and check if its count is reduced to 0.    while(right<ls) {        char c=s[right];        if(map.find(c)!=map.end()) {            --map[c];            if(map[c]==0) --counter;        }        ++right;        // 4. Once the counter becomes 0, move the left pointer to the right, remove s[left] from the window,        while(counter==0) {            char a=s[left];            if(map.find(a)!=map.end()){                ++map[a]; // NOTE: or we can increment map[a] after condition if(map[a]==0).                if(map[a]==1){  // NOTE: this conditional statement should be inside the map.find() scope, since if a is not in the map (not a char in string t), this statement will set up a new mapping for key a, which is not what we want.                    ++counter;                }            }            // 5. check if the length between right and left is the min length so far.             if(right-left < minLength) {                 minIndex=left;                 minLength=right-left;             }            ++left;        }    }    return minLength==INT_MAX? "" : s.substr(minIndex, minLength);}// method 2:string minWindow2(string s, string t) {    int ls=s.length();    int lt=t.length();    int minLength=INT_MAX, minIndex=0;    if(ls==0 || lt==0 || ls<lt) return "";    unordered_map<char, int> map;    for(auto c: t)        ++map[c];    int counter=map.size();    //cout<<"original counter:"<<counter<<"\n";    int left=0, right=0;    while(right<=ls && left<ls) {        while(counter!=0 && right<ls){            char c=s[right];            if(map.find(c)!=map.end()) {                --map[c];                if(map[c]==0) --counter;            }            ++right;            if(counter==0) break;        }        if(counter==0 && right-left < minLength) {            minIndex=left;            minLength=right-left;        }        char a=s[left];        if(map.find(a)!=map.end()){                        if(map[a]==0){  // NOTE: this conditional statement should be inside the map.find() scope, since if a is not in the map (not a char in string t), this statement will set up a new mapping for key a, which is not what we want.                ++counter;            }            ++map[a];        }        ++left;    }    return minLength==INT_MAX? "" : s.substr(minIndex, minLength);}// jiuzhang solution:string minWindow3(string s, string t) {    unordered_map<char, int> mp;    for (char now : t) {        mp[now] ++;    }    int count = mp.size();    int j = 0;    int ans = INT_MAX;    string res;    for (int i = 0; i < s.size(); i++) {        while(count != 0 && j < s.size()) {            mp[s[j]]--;            if (mp[s[j]] == 0) {                count--;            }            j++;            if (count == 0) {                break;            }        }        if (count == 0 && j - i< ans) {            ans = j - i;            res = s.substr(i, j - i);                    }        if(mp[s[i]] == 0) {            count++;        }        mp[s[i]]++;    }    return res;}// 173. Binary Search Tree Iterator// Stack, Tree, Design:// Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.// Calling next() will return the next smallest number in the BST.// Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.// *** Initial throughts: Since we know that the space complexity is O(h), it tells us that this is a DFS, which is realized by stack. If we want to find out the smallest number in a BST, we need to traverse the tree using inorder traversal (return the left most node first, then the root of the left most node, then find the left most node of root's right child).// One pass!!!class BSTIterator {public:    stack<TreeNode*> s;        // 1. Helper function similar to DFS. Traverse through the left child until hit a NULL, push all the not NULL TreeNode* in the path into the stack.    void traverse(TreeNode *root) {        TreeNode *node=root;        while(node!=NULL){        // NOTE: don't need to do in the following way:        // Push a TreeNode* into stack will not change the value (reference) stored in variable node.//            TreeNode* n=node;//            s.push(n);//            node=node->left;            s.push(node);            node=node->left;        }    }        // 2. Do traverse through the left child until hit a NULL to set up the stack.    BSTIterator(TreeNode *root) {        traverse(root);    }        /** @return whether we have a next smallest number */    // 3. If there is still unexplored node left in the stack, there is a next smallest number    bool hasNext() {        return !s.empty();    }        /** @return the next smallest number */    // 4. For next(), we know that the top of the stack is always the smallest number in nodes that are unexplored. First pop off the top of the stack, then do left traverse to the top node's right child. (Don't need to consider the condition that next->right is NULL here, traverse function will do that for us).    int next() {        TreeNode* next=s.top();        s.pop();        traverse(next->right);        return next->val;    }};// 143. Reorder List// Linked list: (Reverse list, Insert node, Middle node)// Given a singly linked list L: L0?L1?É?Ln-1?Ln,// reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?É//// You may not modify the values in the list's nodes, only nodes itself may be changed.// EX: Given 1->2->3->4, reorder it to 1->4->2->3.// beat 100%!!!struct ListNode {   int val;   ListNode *next;   ListNode(int x) : val(x), next(NULL) {}};// Reverse linked list from head to tail, and return a pointer points to the old tail, the new head.ListNode* reverse(ListNode* head) {    if(head==NULL || head->next==NULL) return head;    // 1. Set prev (left pointer) to head, and curr (right pointer) to head->next    ListNode* curr=head->next;    ListNode* prev=head;    head->next=NULL;    // 2. Loop through the list, reverse the pointer between curr node (right node) and prev node (left node), and move the curr pointer pointing to the next node of curr.    while(curr!=NULL) { // NOTE: the condition here should not be curr->next!=NULL, since we move the curr pointer to the next node at the end of the loop. Therefore, if curr is NULL after we set curr to next node and move the prev to curr, the last node to be reversed is prev node (the node prev points to).        // (1) momorize the next node of curr.        ListNode* temp=curr->next;        // (2) point curr->next to prev.        curr->next=prev;        // (3) move prev to the right.        prev=curr;        // (4) move curr to the right.        curr=temp;    }    return prev;}// Find the middle node and return a pointer to it.// If list after head has n nodes, the middle node is node with index n/2. (first node's index is 0)// IDEA: set a slow and a fast pointer, first point them to head, then move slow by 1 and move fast by 2, or by 1 if it reaches the last node of the list in one loop, until the node fast points to has no next node.ListNode* findMiddle(ListNode* head) {    ListNode* slow=head;    ListNode* fast=head;    while(fast->next!=NULL) {        slow=slow->next;        fast=fast->next;        if(fast->next!=NULL)            fast=fast->next;    }    return slow;}// Insert the node t points to after the node h points to.// h is the head of the inorder list, t is the head of the reversed list.// exit the loop until tail pointer t is NULL (no more node to be inserted in the reversed list).void insertNode(ListNode* h, ListNode* t) {    while(t!=NULL) {        ListNode* temp=t;        t=t->next;        temp->next=h->next;        h->next=temp;        h=temp->next;    }}// IDEA: first find the middle node, middle->next is the head pointer of the list to be reversed.//      Then reverse the node after middle->next pointer, and keep the head pointer of the reversed list.//      Use insertNode function to insert each node in the reversed list between each 2 nodes in the first part of the original list.// NOTE: this is a void function, don't need to return head pointervoid reorderList(ListNode* head) {    if(head==NULL || head->next==NULL)        return;    ListNode* middle=findMiddle(head);    ListNode* t=reverse(middle->next);    middle->next=NULL;    ListNode* h=head;    insertNode(h,t);}// 560. Subarray Sum Equals K// Hash table, prefix sum:// Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.// Input:nums = [1,1,1], k = 2// Output: 2// IDEA: loop through the vector and calculate prefix sum, use hash table (map) to store count of a prefixSum. Then search for the target prefixSum - k in the map, add the count prefixSum - k maps to the counter. Finally, increment the count that prefixSum maps to.int subarraySum(vector<int>& nums, int k) {    int size=nums.size();    if(size==0) return 0;    int prefixSum=0;    int count=0;    unordered_map<int,int> map;    // NOTE: need to first map 0 to 1    map[0]=1;    for(int i=0; i<size; ++i) {        prefixSum+=nums[i];        if(map.find(prefixSum-k)!=map.end())            count+=map[prefixSum-k];        ++map[prefixSum];    }    return count;}// faster version:int subarraySum2(vector<int>& nums, int k) {    int size=nums.size();    if(size==0) return 0;    int prefixSum=0;    int count=0;    unordered_map<int,int> map;    // NOTE: need to first map 0 to 1    map[0]=1;    for(int i=0; i<size; ++i) {        prefixSum+=nums[i];        // NOTE: store the target, prefixSum - k, in a variable then use it as the key is much faster!!!        int target=prefixSum-k;        if(map.find(target)!=map.end())            count+=map[target];        ++map[prefixSum];    }    return count;}int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}