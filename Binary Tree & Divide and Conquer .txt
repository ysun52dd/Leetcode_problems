Binary Tree & Divide and Conquer//  binary tree traversal////  Created by SunYutong on 7/14/18.//  Copyright © 2018 SunYutong. All rights reserved.//// week 3: Binary Tree & Divide and Conquer#include <iostream>#include <vector>#include <string>#include <stdio.h>#include <math.h>using namespace std;struct TreeNode {    int val;    TreeNode *left;    TreeNode *right;    TreeNode(int x) : val(x), left(NULL), right(NULL) {}};// Preorder Traversal://Given a binary tree, return the preorder traversal of its nodes' values.////For example://Given binary tree {1,#,2,3},////1//&nbsp;//2/////3//return [1,2,3].    vector<int> preorder;    //helper function for preorderTraversal    void traverse(TreeNode *root) {        if (root == NULL) {            return;        }        preorder.push_back(root->val);        //iteration left        traverse(root->left);        //iteration right        traverse(root->right);    }    vector<int> preorderTraversal(TreeNode *root) {        preorder.clear();        traverse(root);        return preorder;    }// Inorder Travesal:// left->root->rightclass inorderSolution {    /**     * param root: The root of binary tree.     * return: Inorder in vector which contains node values.     */public:    vector<int> inorder;        void traverse(TreeNode *root) {        if (root == NULL) {            return;        }        traverse(root->left);        inorder.push_back(root->val);        traverse(root->right);    }        vector<int> inorderTraversal(TreeNode *root) {        inorder.clear();        traverse(root);        return inorder;        // write your code here    }};//257. Binary Tree Paths//Given a binary tree, return all root-to-leaf paths.////Note: A leaf is a node with no children.////Example:////Input:////  1///   \//2     3// \//  5////Output: ["1->2->5", "1->3"]////Explanation: All root-to-leaf paths are: 1->2->5, 1->3// Java method://public List<String> binaryTreePaths(TreeNode root) {//    List<String> answer = new ArrayList<String>();//    if (root != null) searchBT(root, "", answer);//    return answer;//}//private void searchBT(TreeNode root, String path, List<String> answer) {// leaf//    if (root.left == null && root.right == null) answer.add(path + root.val);// traverse left//    if (root.left != null) searchBT(root.left, path + root.val + "->", answer);// traverse right//    if (root.right != null) searchBT(root.right, path + root.val + "->", answer);//}//METHOD 1: traverse methodvoid helper(TreeNode* root, vector<string>& res,vector<int> t){    if(!root){        return ;    }    t.push_back(root->val);    //iteration exit: leaf    if(!root->left&&!root->right){        string s;        for(int i=0;i<t.size()-1;i++){            s+=to_string(t[i])+"->";        }        //convert int to string        s+=to_string(t[t.size()-1]);        res.push_back(s);    }    helper(root->left,res,t);    helper(root->right,res,t);}vector<string> binaryTreePaths(TreeNode* root) {    vector<string> res;    vector<int> t;    helper(root,res,t);    return res;}//METHOD 2: divide and conquer methodvector<string> binaryTreePaths2(TreeNode* root) {    vector<string> paths;    if (root == NULL)        return paths;    if(!root->left&&!root->right){        paths.push_back(to_string(root->val));        return paths;    }    vector<string> leftPaths = binaryTreePaths2(root->left);    vector<string> rightPaths = binaryTreePaths2(root->right);    for(int i=0;i<leftPaths.size();i++){        paths.push_back(to_string(root->val)+"->"+leftPaths[i]);    }        for(int i=0;i<rightPaths.size();i++){        paths.push_back(to_string(root->val)+"->"+rightPaths[i]);    }        return paths;}//110. Balanced Binary Tree//Given a binary tree, determine if it is height-balanced.////For this problem, a height-balanced binary tree is defined as:////a binary tree in which the depth of the two subtrees of every node never differ by more than 1.// when we need ResultType//only use divide and conquerclass ResultType{public:    bool balanced;    int depth;    //constructor!!!    ResultType(bool b, int d):balanced(b), depth(d){};};ResultType helper(TreeNode* root){    // 3. exit    if(root == NULL)        return ResultType(true, 0);    // 2. split    ResultType left = helper(root->left);    ResultType right = helper(root->right);        //subtree is not balanced    if(!left.balanced || !right.balanced)        //if one of the subtrees is not balance, the tree from the root is not balanced, depth does not matter        return ResultType(false, -1);    if(abs(left.depth-right.depth)>1)        //if 2 subtrees are balanced, but there depthes has a diff larger than 1    //the tree from the root is not balanced        return ResultType(false, -1);    // balanced    int depth = fmax((float)left.depth,(float)right.depth)+1;    return ResultType(true, depth);}bool isBalanced(TreeNode* root) {    return  helper(root).balanced;}// Subtree with Max Average//Traverse + Divide and Conquerclass ResultType2{public:    int sum;    int size;    //constructor!!!    ResultType2(int x, int y):sum(x), size(y){};};class Solution{private:    //global variables:    //pointer to root of the overall max average subtree    TreeNode* subtree;    //sum of all nodes and # of nodes of the overall max average subtree    ResultType2 subtreeResult;    private: ResultType2 helper(TreeNode* root){    if(root == NULL)        return ResultType2(0, 0);        ResultType2 left = helper(root->left);    ResultType2 right = helper(root->right);    ResultType2 result = ResultType2(left.sum+right.sum+root->val, left.size+right.size+1);        //if subtree sum/subtree size < result sum/result size    //overall average < current average    if(subtree == NULL || subtreeResult.sum * result.size<result.sum*subtreeResult.size)    {        //update max subtreeResult and subtree to current        subtree=root;        subtreeResult=result;    }    return result;}    public: TreeNode* findSubtree2(TreeNode* root){    helper(root);    return subtree;}    };// 114. Flatten Binary Tree to Linked List//Given a binary tree, flatten it to a linked list in-place.////For example, given the following tree:////    1//   / \//  2   5// / \   \//3   4   6//The flattened tree should look like:////1// \//  2//   \//    3//     \//      4//       \//        5//         \//          6TreeNode* flattenHelper(TreeNode* root){    if(root==NULL)        return NULL;    // pointer to last node in fallten linked list of left subtree and right subtree    TreeNode* leftLast = flattenHelper(root->left);    TreeNode* rightLast = flattenHelper(root->right);        //connect leftLast, the result after flatten subtree under root->left,to point to node that root->right points to    // root->return value from left->return value from right    if (leftLast != NULL){        leftLast->right=root->right;        //connect the linked list from left to right pointer of the root        root->right=root->left;        //disable the left pointer of the root        root->left=NULL;    }    if (rightLast!=NULL) {        return rightLast;    }    //if rightLast==NULL and    if (leftLast!=NULL) {        return leftLast;    }    // rightLast=NULL and leftLast=NULL (leaf)    return root;}void flatten(TreeNode* root) {    flattenHelper(root);}//236. Lowest Common Ancestor of a Binary Tree (LCA)//Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.////According to the definition of LCA on Wikipedia: ÒThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).Ó//All of the nodes' values will be unique!!!//p and q are different and both values will exist in the binary tree.// Divide and Conquer:// do following to left and right subtree:// if we find LCA, return this root// if we only find node1, p, return p// if we only find node2, q, return q// if we neither find node1 nor node2, return NULLTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {    // last 3 conditions:    if(root == NULL || root == p || root == q)        return root;        // Divede    TreeNode* left = lowestCommonAncestor(root->left, p, q);    TreeNode* right = lowestCommonAncestor(root->right, p, q);        // Conquer    // return root if p and q are found in left and right subtree    //All of the nodes' values will be unique!!!    if (left!=NULL && right!=NULL)        return root;    // if we find something on the left but right    if (left!=NULL)        return left;    // if we find something on the right but left    if (right!=NULL)        return right;    // if both left and right return NULL, noting was found, return NULL    return NULL;}//595. Binary Tree Longest Consecutive Sequence//Given a binary tree, find the length of the longest consecutive sequence path.////The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).//Example://For example,//// 1//  \//   3//  / \// 2   4//      \//       5//Longest consecutive sequence path is 3-4-5, so return 3.////   2//    \//     3//    ///   2//  /// 1//Longest consecutive sequence path is 2-3,not3-2-1, so return 2.int longest;int longestHelper(TreeNode* root){    if (root == NULL)        return 0;    int left = longestHelper(root->left);    int right = longestHelper(root->right);        // longest sequence path within each iteration    int subtreeLongest = 1; // at least we have a root    // if root have a legal left subtree (from parent to child)    if (root->left != NULL && root->val+1 == root->left->val)        subtreeLongest = fmax((double)subtreeLongest, (double)(left +1));    // if root have a legal rihgt subtree    if (root->right != NULL && root->val+1  == root->right->val)        subtreeLongest = fmax((double)subtreeLongest, (double)(right +1));    // compare the longest subtree path in each level to the global longest path    if (subtreeLongest > longest) {        longest = subtreeLongest;    }        return subtreeLongest;}int longestConsecutive(TreeNode * root) {    // write your code here    longest=0;    longestHelper(root);    return longest;}// 614. Binary Tree Longest Consecutive Sequence II//Given a binary tree, find the length of the longest consecutive sequence path. The path could be start and end at any node in the tree// version 1://int longest2;//class ResultTypeLong {//public://    double max_down, max_up;//    ResultTypeLong(double down,double up) {//        max_down = down;//        max_up = up;//    }//};////ResultTypeLong longestHelper2(TreeNode* root)//{//    if (root == NULL)//        return ResultTypeLong(0,0);//    ResultTypeLong left = longestHelper2(root->left);//    ResultTypeLong right = longestHelper2(root->right);////    // longest down & up sequence path within each iteration//    double down = 0, up = 0;//    int subtreeLongest=1;//    // if root have a legal left subtree and the sequence is increasing//    if (root->left != NULL && root->val+1 == root->left->val)//        up = fmax(up, (left.max_up+1));//    // right down//    if (root->right != NULL && root->val  == root->right->val+1)//        down = fmax(down, (right.max_down +1));//    // if root have a legal rihgt subtree and the sequence is increasing//    if (root->right != NULL && root->val+1  == root->right->val)//        up = fmax(up, (right.max_up +1));//    // left down//    if (root->left != NULL && root->val == root->left->val+1)//        down = fmax(down, (left.max_down+1));//    subtreeLongest=(int)(down +up+1);//    // compare the longest subtree path in each level to the global longest path//    if (subtreeLongest > longest2) {//        longest2 = subtreeLongest;//    }////    return ResultTypeLong(down, up);//}////int longestConsecutive2(TreeNode * root) {//    // write your code here//    longest2=0;//    longestHelper2(root);//    return longest2;//}//// version 2:class ResultTypeLong {public:    double max_down, max_up,max_len;    ResultTypeLong(int len, double down,double up) {        max_len=len;        max_down = down;        max_up = up;    }};ResultTypeLong longestHelper2(TreeNode* root){    if (root == NULL)        return ResultTypeLong(0,0,0);    ResultTypeLong left = longestHelper2(root->left);    ResultTypeLong right = longestHelper2(root->right);        // longest down & up sequence path within each iteration    double down = 0, up = 0;    //int subtreeLongest=1;    // if root have a legal left subtree and the sequence is increasing    if (root->left != NULL && root->val+1 == root->left->val)        up = fmax(up,left.max_up+1);    // right down    if (root->right != NULL && root->val  == root->right->val+1)        down = fmax(down, right.max_down +1);    // if root have a legal rihgt subtree and the sequence is increasing    if (root->right != NULL && root->val+1  == root->right->val)        up = fmax(up, right.max_up +1);    // left down    if (root->left != NULL && root->val == root->left->val+1)        down = fmax(down, left.max_down+1);    double len=down +up+1;    // compare the longest subtree path in each level to the global longest path   len = fmax(len, fmax(left.max_len, right.max_len));        return ResultTypeLong(len,down, up);}int longestConsecutive2(TreeNode * root) {    // write your code here            return (int)longestHelper2(root).max_len;}// lintcode 376. Binary Tree Path Sum//Given a binary tree, find all paths that sum of the nodes in the path equals to a given number target.////A valid path is from root node to any of the leaf nodes.//Example//Given a binary tree, and target = 5:////   1//  / \// 2   4/// \//2  3//return//[// [1, 2, 2],// [1, 4]// ]// Traverse:void pathHelper(TreeNode* root, vector<int> path, int sum, int target, vector<vector<int>>& result){    // at leaf    // Binary Tree Path Sum II: add a loop removing one element from top each time    if(root->left==NULL && root->right==NULL) {        if(sum==target){            result.push_back(path);        }        return;    }        // go left    if(root->left!=NULL)    {        path.push_back(root->left->val);        pathHelper(root->left, path, sum+ root->left->val, target, result);        // keep path the same as before        path.pop_back();    }        // go right    if(root->right!=NULL)    {        path.push_back(root->right->val);        pathHelper(root->right, path, sum+root->right->val, target, result);        // keep path the same as before        path.pop_back();    }}vector<vector<int>> binaryTreePathSum(TreeNode * root, int target) {    // write your code here    // traverse method:    vector<vector<int>> result;    if(root == NULL)        return result;    vector<int> path;    path.push_back(root->val);    pathHelper(root, path, root->val, target, result);    return result;}//  Binary Tree Path Sum III// Give a binary tree, and a terget number, find all path that the sum of nodes equal to target, the path could be start and end at any node in the tree.// there is one and only one path between 2 nodes in a binary tree// Lintcode 378. Convert Binary Search Tree to Doubly Linked List// Convert a binary search tree to doubly linked list with in-order traversal.//Given a binary search tree:////    4//   / \//  2   5// / \//1   3//return 1<->2<->3<->4<->5class DoublyListNode {public:    int val;    DoublyListNode *next, *prev;    DoublyListNode(int val) {    this->val = val;    this->prev = this->next = NULL;    }};// pointer to dummy nodeDoublyListNode* inorder=new DoublyListNode(0);// helper function for bstToDoublyList// pre is a pointer to the previous node in linked listDoublyListNode* inorderTraverse(TreeNode *root, DoublyListNode* pre) {    if (root == NULL) {        return NULL;    }    //iterate left, skip if no left child to avoid following null pointer    if(root->left!=NULL)        pre=inorderTraverse(root->left, pre);    //preorder.push_back(root->val);        DoublyListNode* node = new DoublyListNode(root->val);    // connect dummy node to first node    if(inorder->next==NULL){        inorder->next=node;        pre=inorder;        node->prev=inorder;    }    pre->next=node;    node->prev=pre;    pre=node;               //iterate right, skip if no right child to avoid following null pointer    if(root->right!=NULL)        pre=inorderTraverse(root->right, pre);    return pre;}DoublyListNode * bstToDoublyList(TreeNode * root) {    // write your code here    // Traverse:    inorder->next=inorder->prev=NULL;    inorderTraverse(root, inorder);    return inorder->next;}//int main(int argc, const char * argv[]) {    // insert code here...    TreeNode n1(4);    TreeNode n2(2),n3(5),n4(1),n5(3);    //,n6(6),n7(7);    n1.left=&n2;    n1.right=&n3;    n2.left=&n4;    n2.right=&n5;//    n4.left=&n6;//    n4.right=&n7;////    bool balanced;//    vector<string> solution;    //solution=binaryTreePaths2(&n1);//    for(int i=0; i<solution.size(); i++)//    {//        //need to first convert string to c string to print string in c++//        printf("%s",solution[i].c_str());//    }    //balanced=isBalanced(&n1);        //cout<<balanced;//    if(balanced==true)//        printf("true");//    else//        printf("false");//////    vector<vector<int>> solution;//    solution=binaryTreePathSum(&n1, 13);//    for(int i=0; i<solution.size(); i++)//    {//        for(int j=0; j<solution[i].size(); j++)//            printf("%d ",solution[i][j]);//        printf(" ");//    }//    printf("%ld %ld", solution.size(), solution[0].size());        DoublyListNode* solution= bstToDoublyList(&n1);   while(solution->next!=NULL)            {                                printf("%d ",solution->val);                printf(" ");                solution=solution->next;            }    return 0;}