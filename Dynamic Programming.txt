Dynamic Programming//  Dynamic Programming////  Created by SunYutong on 8/9/18.//  Copyright ï¿½ 2018 SunYutong. All rights reserved.//#include <iostream>#include <vector>#include <stack>#include <math.h>#include <unordered_map>#include <unordered_set>using namespace std;// ????// Think about the possible last node of the current position, sum the stored value of all possible last nodes.// 120. Triangle// DFS: Divide & conquer O(2^n)// DFS: Divide & conquer with memorization O(n^2)// use DP (memorization) to reduce the time complexity from O(2^n) to O(n^2)// space complexity: O(n)int minimumTotal(vector<vector<int>>& triangle) {    int size=triangle.size();    if(size==0)        return 0;    // 1. path is an array of size n to store the min path length at position j at each level    // We can keep updating the array at each level, and store only n numbers rather than n^2 numbers    vector<int> path(triangle[size-1].size());    path[0]=triangle[0][0];    for(int i=1; i<triangle.size(); i++) {        //2. Loop through all nodes in each level    // NOTE: loop from outside to inside to avoid erasing the data from last row at j-1 if we want to calculate element j for next row.        for(int j=triangle[i].size()-1; j>=0; j--) {            // 3. Consider the situations that a node only have 1 parent (nodes at 2 sides)            if(j==0) // if the node is the left most node                path[j]=path[j]+triangle[i][j];            else if(j==triangle[i].size()-1) // if it is the right most node                path[j]=path[j-1]+triangle[i][j];            else { // if the node at (i,j) has 2 parents                path[j]=min(path[j-1],path[j])+triangle[i][j];            }        }    }    // 4. Sort the array from smallest to largest with O(nlogn) method, and return the first element in the vector path.    sort(path.begin(), path.end());    return path[0];}// ***84. Largest Rectangle in Histogram (hard!!!)// Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.// Input: [2,1,5,6,2,3]// Output: 10// Stack, array:int largestRectangleArea(vector<int>& heights) {    int size=heights.size();    if(size==0)        return 0;    if(size==1)        return heights[0];    int result=0;    stack<int> pos; // 1. Set a stack to store indexes and the heights at these indexes are in non-decreasing order. These positions are possible starting points which might form a max rectangle.    vector<int>& temp=heights;    pos.push(0);    for(int i=0; i<size; i++) {        // 2. Add the position index into stack if the height at this index is larger than the top of the stack, which means that it has the opptunity to be the starting point to form a larger rectangle than the rectangle starting from the position index on the top of the stack.        if(pos.empty() || (!pos.empty() && temp[i]>=temp[pos.top()])) { // first element or incline (might form a rectangle that beats the earlier ones)            pos.push(i);        }        else { //3. at the first decline, loop to calculate all rectangles before index i (not including)            while(!pos.empty() && temp[i]<temp[pos.top()]) {                int index=pos.top(); pos.pop();                int w=pos.empty()? i:(i-pos.top()-1); // -1 because it does not include position i                result=fmax(result, temp[index]*w);            }            pos.push(i);        }    }    // 4. pop out all elements left in stack, and use all the left index to calculate all possible rectangle area.    // same as while loop in step 3 with i changed to size since it need to consider all rectangles before size-1 (including size-1). We can assume that at index size, height is 0 (which is for sure < pos.top()).    while(!pos.empty() ) {        int index=pos.top(); pos.pop();        int w=pos.empty()? size:(size-pos.top()-1);        result=fmax(result, temp[index]*w);    }    return result;}// 63. Unique Paths II (DP on grid)// Adding the number of possible path to the top node and left node together to calculate number of paths to the current node.//A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).////The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).////Now consider if some obstacles are added to the grids. How many unique paths would there be?// Method 1: Store the grid with possible path to node on a grid. Space: O(m*n)int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {    int m=obstacleGrid.size(); // # of rows    int n=obstacleGrid[0].size(); // # of columns    vector<vector<int>>& pathNum=obstacleGrid;    // 1. Set all points on the first row and first column to their previous points (points above and points on the left), since the robot can only go straight down or right    for(int i=0; i<m; i++) { // first row        if(pathNum[i][0]==1) // 2. Set the path number to the point to 0, if it is originally 1. And it will eliminate the influence of the node to its later nodes.            pathNum[i][0]=0;        else if(i>0)            pathNum[i][0]=pathNum[i-1][0];        else // i=0            pathNum[i][0]=1;    }    for(int i=1; i<n; i++) { // first column, skip (0,0), already checked in the first row        if(pathNum[0][i]==1 && i!=0)            pathNum[0][i]=0;        else            pathNum[0][i]=pathNum[0][i-1];    }    for(int i=1; i<m; i++) {        for(int j=1; j<n; j++) {            if(pathNum[i][j]==1) // skip the illegal nodes                pathNum[i][j]=0;            else // 3. Number of paths from start to a node (i,j) is the sum of the number of paths to node (i-1,j) and (i,j-1)                pathNum[i][j]=pathNum[i-1][j]+pathNum[i][j-1];        }    }    return pathNum[m-1][n-1];}// Method 2: Store the path number in an array of size n. Space: O(n)// faster solution, and save space:int uniquePathsWithObstacles2(vector<vector<int>>& obstacleGrid) {    int m=obstacleGrid.size(); // # of rows    int n=obstacleGrid[0].size(); // # of columns    // 1. Have an array of size n to store number of paths to all n nodes in each row.    int pathNum[n]={0};    pathNum[0]=1;    for(int i=0;i<m;i++) {        for(int j=0;j<n;j++) {            if(obstacleGrid[i][j]==1) {// 2. For each row, set the pathNum[j] at index j to 0 if that node on the grid in row i is 1 (illegal point).                pathNum[j]=0;            }            // 3. If current node is not in the first column, number of paths from start to a node (i,j)  is the sum of the number of paths to node (i-1,j) (currently stored in pathNum[j]) and (i,j-1) (currently stored in pathNum[j-1]).            else if(j!=0){                pathNum[j]+=pathNum[j-1];            }            // 4. Keep pathNum[0] unchanged for each row if node (i,0) is not illegal (obstacleGrid[i][j]==1).        }    }    // 5. Return the last element of the pathNum array.    return pathNum[n-1];}// 62. Unique Paths// Calculate total number of unique paths from (0,0) to (m-1,n-1). The robot can only move down and right. m is the number of rows and n is the nubmer of columns.// DP, O(n) spaceint uniquePaths(int m, int n) {    if(n==0 || m==0)        return 0;    // 1. Have an array of size n to store number of paths to all n nodes in each row.    int pathNum[n]={0};    pathNum[0]=1;    for(int i=0;i<m;i++) {        for(int j=0;j<n;j++) {            // 3. If current node is not in the first column, number of paths from start to a node (i,j)  is the sum of the number of paths to node (i-1,j) (currently stored in pathNum[j]) and (i,j-1) (currently stored in pathNum[j-1]).            if(j!=0){                pathNum[j]+=pathNum[j-1];            }            // 4. Keep pathNum[0] unchanged for each row.        }    }    // 5. Return the last element of the pathNum array.    return pathNum[n-1];}// 70. Climbing Stairs// You are climbing a stair case. It takes n steps to reach to the top.//Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?//Note: Given n will be a positive integer.int climbStairs(int n) {    if(n<=2) return n;    int dp[n]; // 1. setup an array to store number of paths to all n starirs    dp[0]=1; dp[1]=2; // 2. initialize # of path to first 2 stairs to 1 and 2    for(int i=2; i<n; i++) {        dp[i]=dp[i-1]+dp[i-2]; // 3. number of steps to stair i is the sum of paths to i-1 and steps to i-2 since step can only be of length 1 or 2.    }    return dp[n-1]; // 4. return value is stored in position n-1, the last stair}// 64. Minimum Path Sum// Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.int minPathSum(vector<vector<int>>& grid) {    // ERROR: Need to first check if m is 0, no row in grid, then access to the first element of grid (use gird[0].size()).        int m=grid.size(); // rows        if(m==0) return 0;        int n=grid[0].size(); // columns        if(n==0) return 0;        int dp[n]={0};        for(int i=0; i<m; i++) {            dp[0]+=grid[i][0];            for(int j=1; j<n; j++) {                if(i==0) { // 1. First initialize the first row with the prefix sum from the left most element to the current element.                    dp[j]=dp[j-1]+grid[i][j];                    continue;                }// 2. Choose the one with smaller path length so far between the left element (the previous element in dp[]) and the top element (stored in dp[j], the same index in dp[]).                dp[j]=min(dp[j-1],dp[j])+grid[i][j];            }        }    // 3. return the last element in dp after going through all rows.        return dp[n-1];    }// *************************************// ????often use back tracking, or forward checking// 300. Longest Increasing Subsequence// looking for all legal last positions before current position// Input: [10,9,2,5,3,7,101,18]//Output: 4//Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.// method 1: slower int lengthOfLIS(vector<int>& nums) {     int size=nums.size();     if(size==0) // NOTE: need to consider size==0, since sub[0] is invalid         return 0;     int sub[size]={0}; // 1. Set an array to store max subsequence length so far     sub[0]=1;     int result=1;       // 2. Loop through all elements, and retrive max subsequence length in all the previous elements < current element, then find the choose with larger length.     for(int i=1; i<size; i++) {        // condition 1: if nums[i] is in the subsequence, find the max in all number of subsequence before index i, and +1         int max=0;         for(int j=i-1; j>=0; j--) {             if(nums[j]<nums[i]){                 max=fmax(sub[j],max);             }         } // condition 2: if nums[i] is not in the subsequence, sub[i] is the same as sub[i-1]         // 3. If there is no number before nums[i] that is < nums[i], start a new sequence, set sub[i] to 1.         if(max==0)             sub[i]=1;         else {              // 4. If there is number < than nums[i] before, set sub[i] to max+1, lengthen the subsequence by 1             result=fmax(max+1,result); // choose the larger number of subsequence between 2 conditions, and store it in sub[i]             sub[i]=max+1;         }     }     return result; }// method 2: faster one, O(n^2)int lengthOfLIS2(vector<int>& nums) {    int size=nums.size();    if(size==0) // NOTE: need to consider size==0, since sub[0] is invalid        return 0;    int sub[size]={0}; // 1. Set an array to store max subsequence length to index i, and a integer result to be the max subsequence length until the last index.    sub[0]=1;    int result=1; // NOTE: need to be set to 1, at least 1 element in the subsequence.    for(int i=1; i<size; i++) {        // 2. Loop through all elements, and retrive max subsequence length in all the previous elements < current element, then find the choose with larger length.            // condition 1: if nums[i] is in the subsequence, find the max in all number of subsequence before index i, and + 1            // condition 2: if nums[i] is not in the subsequence, result till i is the same as result till i-1        // ***NOTE: first set starting value of all elemnets to 1 ************        sub[i]=1;        for(int j=i-1; j>=0; j--) {            if(nums[j]<nums[i]) // 3. choose the larger number of subsequence between 2 conditions, and store it in result                sub[i]=sub[i]>sub[j]+1 ? sub[i] : sub[j]+1;        }            result=fmax(result,sub[i]);    }    return result;}// method 3: O(nlogn)int lengthOfLIS3(vector<int>& nums) {    vector<int> res;    for(int i=0; i<nums.size(); i++) {        auto it = std::lower_bound(res.begin(), res.end(), nums[i]); // # of elements >= nums[i]        if(it==res.end()) res.push_back(nums[i]);        else *it = nums[i];    }    return res.size();}// 279. Perfect Squares ****************// Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.// Input: n = 12// Output: 3// Explanation: 12 = 4 + 4 + 4.// DP method 1: ????int numSquares(int n) {    // assume the last added square number is k    vector<int> dp{ 0 };    dp.resize(n + 1, INT_MAX);    for(int i=1,k; (k=i*i)<=n; i++) {        for(int j=k; j<=n; j++) {            dp[j]=fmin(dp[j-k]+1,dp[j]);        }    }    return dp[n];}// DP method 2: faster ***************int numSquares2(int n) {        vector<int> dp{ 0 }; // dp is an array to store the min numbers of square numbers' sum to get number i    dp.resize(n + 1, INT_MAX);    for(int i=1; (i*i)<=n; i++) //1. set perfect square numbers dp[i^2] all to 1        dp[i*i]=1;        for(int i=0; i<=n; i++) { // 2. loop through n+1 starting points (0~n), the first added number to the sum.        for(int j=0; i+j*j<=n; j++) //3. adding another perfect square number j^2, calculate the dp of the following number until it reaches n.            dp[i+j*j]=fmin(dp[i]+1,dp[i+j*j]);    }    return dp[n];}// 368. Largest Divisible Subset// Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.//If there are multiple solutions, return any subset is fine.// nums: [1,2,3]//Result: [1,2] (of course, [1,3] will also be ok)vector<int> largestDivisibleSubset(vector<int>& nums) {    int size=nums.size();    vector<int> result;    if(size==0) return result;    int dp[size]={0}; // dp array to store the length of subset until index i    int p[size]; p[0]=0; // store the previous element position    int max=INT_MIN, max_i=0;    // sort from small to large    sort(nums.begin(), nums.end());    for(int i=0; i<size; i++) {        dp[i]=1;        for(int j=i; j>=0; j--) {            if(nums[i]%nums[j] == 0){                if(dp[j]+1>dp[i]){                    dp[i]=dp[j]+1;                    p[i]=j;                }            }        }        // find max within all position from 0 to size-1, store the position that achieve the maximum        if(dp[i] > max) {            max=dp[i];            max_i=i;        }    }    // retrive the path backward from element at max_i to 0    result.push_back(nums[max_i]);    while(max_i!=p[max_i]) { // WRONG: max_i!=0        max_i=p[max_i];        result.push_back(nums[max_i]);    }    // reverse the vector    reverse(result.begin(), result.end());    return result;}// 403. Frog Jump (hard)// How to store and arrange large amount of memory.// unordered_map, unordered_set, dp// method 1: DP, back tracking// slower version O(n^2)bool canCross(vector<int>& stones) {    int size=stones.size();    if(size==0) return false;    if(size==1) return true;    if(stones[1]-stones[0]!=1) return false; // 1. Check if the first step is length 1, (first setp must be from stones[0] to stones[1] since numbers after stones[1] are larger)    // ERROR: don't use vector<vector<int>> to store all possible previous stone, exceed memory limit.    //vector<vector<int>> dp; dp.resize(size);    unordered_map<int, unordered_set<int>> dp; // 2. use unordered_map of int j to an unordered_set to store all the possible last stones' value for stone at index j    dp[0].insert(0); // set the previous stone index of stones[0] to 0    // 3. Loop through all stones to find all possible legal previous stones, and insert the position of previous stones into the set that current stone's index maps to.    for(int i=1; i<size; i++) {        for(int j=i-1;j>=0; j--) {            for(auto k:dp[j]) { // 4. Loop through all elements (k) of j's set, and check if step from stone j to stone i is >= step from k to stone j - 1 and <= step from k to stone j + 1. If so, insert the stone value at j into i's set.                if(stones[i]-stones[j]<=stones[j]-k+1 && stones[i]-stones[j]>=stones[j]-k-1) {                    dp[i].insert(stones[j]);                    break; // stop checking other previous stones of stones[j] once we find one that is legal.                }            }        }    }    // 5. If the set that index size-1 maps to have nothing in it, which means there is no legal last stone for the stone at size-1, return false. Otherwise, return true.    if(dp[size-1].empty()) return false;    return true;}// method 2: DP, forward checking// method, not step back!!!// Better and faster solution: O(N)bool canCross2(vector<int>& stones) {    int size=stones.size();    if(size==0) return false;    if(size==1) return true;    if(stones[1]-stones[0]!=1) return false;    unordered_map<int, unordered_set<int>> dp; // 1. int is the stone position value stored in stones[i]. unordered_set mapped to int stones[i] is the set of possible step lengthes to current stone stones[i]    // 2. IMPORTANT: initialize all the unordered_set, and set the previous step length of stones[0] to 0    for (auto position : stones)        dp[position] = unordered_set<int>();    dp[0].insert(0);    // 3. find the 3 legal next stones' position values of the current stone (position), and insert the length of the step, k, k-1, k+1 to the set of the next stone    for (auto position : stones) {        for (auto k : dp[position]) {            // k - 1            if (k - 1 > 0 && dp.find(position + k - 1) != dp.end())                dp[position + k - 1].insert(k - 1);            // k            if (dp.find(position + k) != dp.end())                dp[position + k].insert(k);            // k + 1            if (dp.find(position + k + 1) != dp.end())                dp[position + k + 1].insert(k + 1);        }    }    // 4. Return wether there is legal step length to the last stone's position    return !(dp[stones.back()].empty());    }// Greedy Algorithm  ??? (hard for me)// 55. Jump Game// Given an array of non-negative integers, you are initially positioned at the first index of the array.// Each element in the array represents your maximum jump length at that position.// Determine if you are able to reach the last index.bool canJump(vector<int>& nums) {    int size=nums.size();    // 1. return false if the first element is 0 and it is not the only element in nums    if(nums[0]==0 && size!=1) return false;    int farest=nums[0];    // 2. Loop through all elements in nums[], and see if the position i + the max steps it can take next can push the farest line further.    for(int i=0; i<size; i++) {                if(i<=farest && nums[i]+i>farest)            farest=nums[i]+i;    }    // 3. Check if the farest line exceed the last element of nums.    return (farest>=size-1);}// 354. Russian Doll Envelopes// You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.// What is the maximum number of envelopes can you Russian doll? (put one inside other)// ?????bool cmp(const pair<int,int>&x, const pair<int, int>&y) {    return x.first != y.first ? x.first < y.first : x.second > y.second;}int maxEnvelopes(vector<pair<int, int>>& envelopes) {    // Write your code here    int n = envelopes.size();    if (n == 0) {        return 0;    }        sort(envelopes.begin(), envelopes.end(), cmp);    vector<int> dp(n), height(n+1, INT_MAX);    for (int i = 0; i < n; i++) {        // all pairs before envelopes[i] has smaller first number or same first number and larger second number        // so all pairs that have smaller height(second number) than envelopes[i] must also have smaller wide        int k = lower_bound(height.begin(), height.end(), envelopes[i].second) - height.begin() ;        dp[i] = k;        // cout<<"k:"<<k<<"\n";        // update the height[k] to newest height if the 2 pairs have the same total length from the beginning        height[k] = envelopes[i].second;    }        int ans = 0;    for (int i = 0; i < n; i++) {        ans = max(ans, dp[i]);    }    return ans + 1;}int main(int argc, const char * argv[]) {    // insert code here...    std::cout << "Hello, World!\n";    return 0;}